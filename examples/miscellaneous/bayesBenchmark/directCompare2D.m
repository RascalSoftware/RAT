% This example compares three Bayesian posteriors for a low-dimensional
% example: a posterior generated by DREAM, one generated by NS, and
% one calculated directly.
% 
% In this 2D case, we calculate the posterior for a fit over substrate
% roughness and a background parameter.
%
% The likelihood of the parameters being equal to a certain value is proportional
% to exp(-chi^2 / 2) [1], so for a low-dimensional example we can calculate this directly
% for a sample of parameter values.
% 
% Citation:
% [1] D. S. Sivia, J. R. P. Webster,
%     "The Bayesian approach to reflectivity data",
%     Physica B: Condensed Matter,
%     Volume 248, June 1998, pages 327-337
%     DOI: 10.1016/S0921-4526(98)00259-2
%     URL: https://bayes.wustl.edu/sivia/98_20feb03.pdf
clear

% Do the direct calculation first.
% Our project is a bare D2O substrate: this is the default RasCAL-1 project.
root = getappdata(0, 'root');
d2oproblem = r1ToProjectClass(fullfile(root, 'utilities', 'misc', 'defaultR1ProjectTemplate.mat'));

controls = controlsClass();
controls.nsTolerance = 1;
controls.nLive = 500;
d2oproblem.setScalefactor(1,'fit',false);

gridSize = 30;
% Make a vector of roughness values..
paramsTable = d2oproblem.parameters.varTable;
minRough = paramsTable{1,2};
maxRough = paramsTable{1,4};
roughVector = linspace(minRough, maxRough, gridSize);

% Also background...
backParsTable = d2oproblem.background.backgroundParams.varTable;
minBack = backParsTable{1,2};
maxBack = backParsTable{1,4};
backsVector = linspace(minBack, maxBack, gridSize);

% We create a 30x30 array to store our results:
probArray = zeros();
counter = 1;
totalGrid = gridSize^2;

% Now for the calculation over 30 sample points for each axis:
controls.procedure = 'calculate';
controls.display = 'off';

for r = 1:gridSize
    for b = 1:gridSize
        thisRough = roughVector(r);
        thisBack = backsVector(b);

        d2oproblem.setParameter(1,'value',thisRough);
        d2oproblem.setBackgroundParam(1,'value',thisBack);

        [outProblem,results] = RAT(d2oproblem,controls);
        thisChi = results.calculationResults.sumChi;
        probArray(r,b) = exp(-thisChi/2);
        percent = (counter/totalGrid)*100;
        fprintf('Calculated %1.1f percent \n',percent);
        counter = counter + 1;
    end
end

figure(2); clf
contour(backsVector,roughVector,probArray,'k-');
hold on

% now we calculate for NS:
controls.procedure = 'ns';
[~,NSResults] = RAT(d2oproblem,controls);

% and plot histograms for posteriors:
NSRes = NSResults.chain;
figure(3); clf; hold on
roughs = NSRes(:,1);
[n,x] = hist(roughs,20,'Normalization','probability');
subplot(1,2,1); hold on
bar(x,n,'w');

backs = NSRes(:,2);
[n,x] = hist(backs,20,'Normalization','probability');
subplot(1,2,2); hold on;
bar(x,n,'w');

rough = NSRes(:,1);
back = NSRes(:,2);
plot(back,rough,'.');

% and for DREAM:
controls.procedure = 'dream';
[~,DResults] = RAT(d2oproblem,controls);

DRes = DResults.chain;
figure(3); clf; hold on
roughs = DRes(:,1);
[n,x] = hist(roughs,20,'Normalization','probability');
subplot(1,2,1); hold on
bar(x,n,'w');

backs = DRes(:,2);
[n,x] = hist(backs,20,'Normalization','probability');
subplot(1,2,2); hold on;
bar(x,n,'w');

rough = DRes(:,1);
back = DRes(:,2);
plot(back,rough,'.');

% Marginalise the distributions for the direct calculation and plot:
roughDist = sum(probArray,[3 2]);
roughDist = [roughVector(:) roughDist(:)];
figure(3); subplot(1,2,1); hold on
plot(roughDist(:,1),roughDist(:,2),'linewidth',2);

backDist = sum(probArray,1);
backDist = sum(backDist,3);
backDist = [backsVector(:) backDist(:)];
figure(3); subplot(1,2,2); hold on
plot(backDist(:,1), backDist(:,2),'linewidth',2);

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of calculate</title>
  <meta name="keywords" content="calculate">
  <meta name="description" content="Standard layers reflectivity calculation for nonPolarisedTF">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003-2019 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../../menu.html targetFunctions -->
<!-- ../menu.html +domainsTF -->
<!-- menu.html +standardLayers -->

<h1>calculate
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>Standard layers reflectivity calculation for nonPolarisedTF</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [problem,reflectivity,Simulation,shifted_data,layerSlds,sldProfiles,allLayers] = calculate(problemDef,problemDefCells,controls) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Standard layers reflectivity calculation for nonPolarisedTF
 This function decides on parallelisation options before calling the
 relevant version of the main standard layers calculation. Parallelisation 
 is either over the outer loop ('contrasts'), or the inner loop
 ('points'). The easiest way to do this is to have multiple versions of 
 the same core calculation, rather than trying to make the parallel
 for loops conditional (although that would be much neater) There are:
 points    - parallelise over points in the reflectivity calculation
 contrasts - parallelise over contrasts (outer for loop)
</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [problem,reflectivity,Simulation,shifted_data,layerSlds,sldProfiles,allLayers] = calculate(problemDef,problemDefCells,controls)</a>
0002 
0003 <span class="comment">% Standard layers reflectivity calculation for nonPolarisedTF</span>
0004 <span class="comment">% This function decides on parallelisation options before calling the</span>
0005 <span class="comment">% relevant version of the main standard layers calculation. Parallelisation</span>
0006 <span class="comment">% is either over the outer loop ('contrasts'), or the inner loop</span>
0007 <span class="comment">% ('points'). The easiest way to do this is to have multiple versions of</span>
0008 <span class="comment">% the same core calculation, rather than trying to make the parallel</span>
0009 <span class="comment">% for loops conditional (although that would be much neater) There are:</span>
0010 <span class="comment">% points    - parallelise over points in the reflectivity calculation</span>
0011 <span class="comment">% contrasts - parallelise over contrasts (outer for loop)</span>
0012 
0013 
0014 <span class="comment">% Pre-allocation - It's necessary to</span>
0015 <span class="comment">% pre-define the types for all the arrays</span>
0016 <span class="comment">% for compilation, so do this in this block.</span>
0017 numberOfContrasts = problemDef.numberOfContrasts;
0018 outSsubs = zeros(numberOfContrasts,1);
0019 backgs = zeros(numberOfContrasts,1);
0020 qzshifts = zeros(numberOfContrasts,1);
0021 scalefactors = zeros(numberOfContrasts,1);
0022 bulkIns = zeros(numberOfContrasts,1);
0023 bulkOuts = zeros(numberOfContrasts,1);
0024 chis = zeros(numberOfContrasts,1);
0025 resols = zeros(numberOfContrasts,1);
0026 allRoughs = zeros(numberOfContrasts,1);
0027 
0028 reflectivity = cell(numberOfContrasts,1);
0029 <span class="keyword">for</span> i = 1:numberOfContrasts
0030     reflectivity{i} = [1 1 ; 1 1];
0031 <span class="keyword">end</span>
0032 
0033 Simulation = cell(numberOfContrasts,1);
0034 <span class="keyword">for</span> i = 1:numberOfContrasts
0035     Simulation{i} = [1 1 ; 1 1];
0036 <span class="keyword">end</span>
0037 
0038 shifted_data = cell(numberOfContrasts,1);
0039 <span class="keyword">for</span> i = 1:numberOfContrasts
0040     shifted_data{i} = [1 1 1; 1 1 1];
0041 <span class="keyword">end</span>
0042 
0043 layerSlds = cell(numberOfContrasts,1);
0044 <span class="keyword">for</span> i = 1:numberOfContrasts
0045     layerSlds{i} = [1 1 1; 1 1 1];
0046 <span class="keyword">end</span>
0047 
0048 sldProfiles = cell(numberOfContrasts,1);
0049 <span class="keyword">for</span> i = 1:numberOfContrasts
0050     sldProfiles{i} = [1 1; 1 1];
0051 <span class="keyword">end</span>
0052 
0053 allLayers = cell(numberOfContrasts,1);
0054 <span class="keyword">for</span> i = 1:numberOfContrasts
0055     allLayers{i} = [1 1 1; 1 1 1];
0056 <span class="keyword">end</span>
0057 <span class="comment">% ------- End type definitions -------------</span>
0058 
0059 
0060 <span class="keyword">switch</span> controls.parallel
0061     <span class="keyword">case</span> <span class="string">'single'</span>
0062           [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,<span class="keyword">...</span>
0063              Simulation,shifted_data,layerSlds,sldProfiles,allLayers,<span class="keyword">...</span>
0064              allRoughs] = domainsTF.standardLayers.single(problemDef,problemDefCells,controls);
0065      <span class="keyword">case</span> <span class="string">'points'</span>
0066           [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,<span class="keyword">...</span>
0067              Simulation,shifted_data,layerSlds,sldProfiles,allLayers,<span class="keyword">...</span>
0068              allRoughs] = domainsTF.standardLayers.parallelPoints(problemDef,problemDefCells,controls);
0069     <span class="keyword">case</span> <span class="string">'contrasts'</span>
0070           [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,<span class="keyword">...</span>
0071              Simulation,shifted_data,layerSlds,sldProfiles,allLayers,<span class="keyword">...</span>
0072              allRoughs] = domainsTF.standardLayers.parallelContrasts(problemDef,problemDefCells,controls);        
0073 <span class="keyword">end</span>
0074 
0075 <span class="comment">% Package everything into one array for tidy output</span>
0076 problem.ssubs = outSsubs;
0077 problem.backgroundParams = backgs;
0078 problem.qzshifts = qzshifts;
0079 problem.scalefactors = scalefactors;
0080 problem.bulkIn = bulkIns;
0081 problem.bulkOut = bulkOuts;
0082 problem.resolutionParams = resols;
0083 problem.calculations.all_chis = chis;
0084 problem.calculations.sum_chi = sum(chis);
0085 problem.allSubRough = allRoughs;
0086 problem.resample = problemDef.resample;
0087 <span class="keyword">end</span>
</pre></div>

<hr><address>Generated on Mon 04-Dec-2023 13:09:56 by <strong><a href="https://github.com/gllmflndn/m2html">m2html</a></strong> &copy; 2003-2022</address>
</body>
</html>

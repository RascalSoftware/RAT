<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of parallelPoints</title>
  <meta name="keywords" content="parallelPoints">
  <meta name="description" content="Single threaded version of the Standard Layers calculation">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003-2019 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../../menu.html targetFunctions -->
<!-- ../menu.html +domainsTF -->
<!-- menu.html +standardLayers -->

<h1>parallelPoints
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>Single threaded version of the Standard Layers calculation</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,domainSldProfiles,allLayers,allRoughs] = parallelPoints(problemDef,problemDefCells,controls) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Single threaded version of the Standard Layers calculation 
 This is the main reflectivity calculation of the standard layers
 calculation type. It extracts the required parameters for the contrasts
 from the input arrays, then passes the main calculation to
 'standardLayersCore', which carries out the calculation itself. 
 The core calculation is common for both standard and custom layers.
</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../targetFunctions/+domainsTF/+customLayers/parallelPoints.html" class="code" title="function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,domainSldProfiles,allLayers,allRoughs] = parallelPoints(problemDef,problemDefCells,controls)">parallelPoints</a>	Single threaded version of the custom layers, domainsTF reflectivity</li>
<li><a href="../../../targetFunctions/+domainsTF/+customXY/parallelPoints.html" class="code" title="function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,domainSldProfiles,allLayers,allRoughs] = parallelPoints(problemDef,problemDefCells,controls)">parallelPoints</a>	Extract individual cell arrays</li>
<li><a href="parallelPoints.html" class="code" title="function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,domainSldProfiles,allLayers,allRoughs] = parallelPoints(problemDef,problemDefCells,controls)">parallelPoints</a>	Single threaded version of the Standard Layers calculation</li>
<li><a href="../../../targetFunctions/+nonPolarisedTF/+customLayers/parallelPoints.html" class="code" title="function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,sldProfiles,allLayers,allRoughs] = parallelPoints(problemDef,problemDefCells,controls)">parallelPoints</a>	Multi threaded version of the custom layers over reflectivity poimnts</li>
<li><a href="../../../targetFunctions/+nonPolarisedTF/+customXY/parallelPoints.html" class="code" title="function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,sldProfiles,allLayers,allRoughs] = parallelPoints(problemDef,problemDefCells,controls)">parallelPoints</a>	Multi threaded version of the custom XY profile over reflectivity points</li>
<li><a href="../../../targetFunctions/+nonPolarisedTF/+standardLayers/parallelPoints.html" class="code" title="function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,sldProfiles,allLayers,allRoughs] = parallelPoints(problemDef,problemDefCells,controls)">parallelPoints</a>	Standard Layers calculation paralelised over the inner loop</li>
<li><a href="../../../targetFunctions/common/backSort.html" class="code" title="function [outBackground,outQzshift,outScalefactor,outBulkIn,outBulkOut,outResolution] = backSort(contrastBackgrounds,contrastQzshifts,contrastScalefactors,contrastBulkIns,contrastBulkOuts,contrastResolutions,backs,qzshifts,scalefactor,bulkIn,bulkOut,res)">backSort</a>	Distributes the background and shift values among the different contrasts</li>
<li><a href="../../../targetFunctions/common/costFunctions/chiSquared.html" class="code" title="function chi2 = chiSquared(thisData,thisFit,P)">chiSquared</a>	Chi-squared function is used to evaluate the goodness of fit.</li>
<li><a href="../../../targetFunctions/common/extractProblemParams.html" class="code" title="function [numberOfContrasts, geometry, contrastBackgrounds, contrastQzshifts, contrastScalefactors, contrastBulkIns, contrastBulkOuts,contrastResolutions, backs, shifts, scalefactor, bulkIn, bulkOut, res, dataPresent, nParams, params,numberOfLayers, resample, backsType, contrastCustomFiles] =  extractProblemParams(problemDef)">extractProblemParams</a>	Extract individual parameters from problemDef</li>
<li><a href="../../../targetFunctions/common/groupLayers/allocateLayersForContrast.html" class="code" title="function     thisContrastLayers = allocateLayersForContrast(contrastLayers,outParameterisedLayers,useImaginary)">allocateLayersForContrast</a>	Decide which layers are needed for a particular contrast.</li>
<li><a href="../../../targetFunctions/common/groupLayers/allocateParamsToLayers.html" class="code" title="function outLayers = allocateParamsToLayers(params, layersDetails)">allocateParamsToLayers</a>	Allocates parameters from the parameter array to the correct layers</li>
<li><a href="../../../targetFunctions/common/parseCells.html" class="code" title="function [repeatLayers,allData,dataLimits,simLimits,contrastLayers,layersDetails,customFiles] = parseCells(problemDefCells)">parseCells</a>	Splits up the master input list of all arrays into separate arrays</li>
</ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../targetFunctions/+domainsTF/+customLayers/parallelContrasts.html" class="code" title="function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,domainSldProfiles,allLayers,allRoughs] = parallelContrasts(problemDef,problemDefCells,controls)">parallelContrasts</a>	Single threaded version of the custom layers, domainsTF reflectivity</li>
<li><a href="../../../targetFunctions/+domainsTF/+customLayers/parallelPoints.html" class="code" title="function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,domainSldProfiles,allLayers,allRoughs] = parallelPoints(problemDef,problemDefCells,controls)">parallelPoints</a>	Single threaded version of the custom layers, domainsTF reflectivity</li>
<li><a href="../../../targetFunctions/+domainsTF/+customLayers/single.html" class="code" title="function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,domainSldProfiles,allLayers,allRoughs] = single(problemDef,problemDefCells,controls)">single</a>	Single threaded version of the custom layers, domainsTF reflectivity</li>
<li><a href="parallelContrasts.html" class="code" title="function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,domainSldProfiles,allLayers,allRoughs] = parallelContrasts(problemDef,problemDefCells,controls)">parallelContrasts</a>	Single threaded version of the Standard Layers calculation</li>
<li><a href="parallelPoints.html" class="code" title="function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,domainSldProfiles,allLayers,allRoughs] = parallelPoints(problemDef,problemDefCells,controls)">parallelPoints</a>	Single threaded version of the Standard Layers calculation</li>
<li><a href="single.html" class="code" title="function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,domainSldProfiles,allLayers,allRoughs] = single(problemDef,problemDefCells,controls)">single</a>	Single threaded version of the Standard Layers calculation</li>
<li><a href="../../../targetFunctions/+nonPolarisedTF/+customLayers/parallelContrasts.html" class="code" title="function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,sldProfiles,allLayers,allRoughs] = parallelContrasts(problemDef,problemDefCells,controls)">parallelContrasts</a>	Multi threaded version of the custom layers, nonPolarisedTF reflectivity</li>
<li><a href="../../../targetFunctions/+nonPolarisedTF/+customLayers/parallelPoints.html" class="code" title="function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,sldProfiles,allLayers,allRoughs] = parallelPoints(problemDef,problemDefCells,controls)">parallelPoints</a>	Multi threaded version of the custom layers over reflectivity poimnts</li>
<li><a href="../../../targetFunctions/+nonPolarisedTF/+customLayers/single.html" class="code" title="function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,sldProfiles,allLayers,allRoughs] = single(problemDef,problemDefCells,controls)">single</a>	Single threaded version of the custom layers, nonPolarisedTF reflectivity</li>
<li><a href="../../../targetFunctions/+nonPolarisedTF/+standardLayers/parallelContrasts.html" class="code" title="function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,sldProfiles,allLayers,allRoughs] = parallelContrasts(problemDef,problemDefCells,controls)">parallelContrasts</a>	Standard Layers calculation paralelised over the outer loop</li>
<li><a href="../../../targetFunctions/+nonPolarisedTF/+standardLayers/parallelPoints.html" class="code" title="function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,sldProfiles,allLayers,allRoughs] = parallelPoints(problemDef,problemDefCells,controls)">parallelPoints</a>	Standard Layers calculation paralelised over the inner loop</li>
<li><a href="../../../targetFunctions/+nonPolarisedTF/+standardLayers/single.html" class="code" title="function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,sldProfiles,allLayers,allRoughs] = single(problemDef,problemDefCells,controls)">single</a>	Single threaded version of the Standard Layers calculation</li>
<li><a href="../../../targetFunctions/+nonPolarisedTF/coreLayersCalculation.html" class="code" title="function [sldProfile,reflect,Simul,shifted_dat,theseLayers,resamLayers,chiSq,ssubs] =coreLayersCalculation(contrastLayers, rough,geometry, bulkIn, bulkOut, resample, calcSld, scalefactor, qzshift,dataPresent, data, dataLimits, simLimits, repeatLayers,background,resol,backsType,params,parallelPoints,resamPars,useImaginary)">coreLayersCalculation</a>	This is the main reflectivity calculation for all Layers models in the</li>
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 
0002 <a name="_sub0" href="#_subfunctions" class="code">function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,</a><span class="keyword">...</span>
0003     Simulation,shifted_data,layerSlds,domainSldProfiles,allLayers,<span class="keyword">...</span>
0004     allRoughs] = <a href="parallelPoints.html" class="code" title="function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,domainSldProfiles,allLayers,allRoughs] = parallelPoints(problemDef,problemDefCells,controls)">parallelPoints</a>(problemDef,problemDefCells,controls)
0005 <span class="comment">% Single threaded version of the Standard Layers calculation</span>
0006 <span class="comment">% This is the main reflectivity calculation of the standard layers</span>
0007 <span class="comment">% calculation type. It extracts the required parameters for the contrasts</span>
0008 <span class="comment">% from the input arrays, then passes the main calculation to</span>
0009 <span class="comment">% 'standardLayersCore', which carries out the calculation itself.</span>
0010 <span class="comment">% The core calculation is common for both standard and custom layers.</span>
0011 
0012 
0013 <span class="comment">% Extract individual cell arrays</span>
0014 [repeatLayers,<span class="keyword">...</span>
0015  allData,<span class="keyword">...</span>
0016  dataLimits,<span class="keyword">...</span>
0017  simLimits,~,<span class="keyword">...</span>
0018  layersDetails,~] = <a href="../../../targetFunctions/common/parseCells.html" class="code" title="function [repeatLayers,allData,dataLimits,simLimits,contrastLayers,layersDetails,customFiles] = parseCells(problemDefCells)">parseCells</a>(problemDefCells);
0019 
0020 <span class="comment">% Additionally extract the additional domain layers details</span>
0021 domainContrastLayers = problemDefCells{19};
0022 
0023 <span class="comment">% Extract individual parameters from problemDef struct</span>
0024 [numberOfContrasts, geometry, contrastBackgrounds, contrastQzshifts, contrastScalefactors, contrastBulkIns, contrastBulkOuts,<span class="keyword">...</span>
0025 contrastResolutions, backs, shifts, scalefactor, bulkIn, bulkOut, res, dataPresent, nParams, params,<span class="keyword">...</span>
0026 ~, resample, backsType, ~] =  <a href="../../../targetFunctions/common/extractProblemParams.html" class="code" title="function [numberOfContrasts, geometry, contrastBackgrounds, contrastQzshifts, contrastScalefactors, contrastBulkIns, contrastBulkOuts,contrastResolutions, backs, shifts, scalefactor, bulkIn, bulkOut, res, dataPresent, nParams, params,numberOfLayers, resample, backsType, contrastCustomFiles] =  extractProblemParams(problemDef)">extractProblemParams</a>(problemDef);
0027 
0028 calcSld = controls.calcSldDuringFit;   
0029 useImaginary = problemDef.useImaginary;
0030 allDomainRatios = problemDef.domainRatio;
0031 contrastDomainRatios = problemDef.contrastDomainRatios;
0032 
0033 domainRatio = 1;    <span class="comment">% Default for compile.</span>
0034 
0035 <span class="comment">% Allocate the memory for the output arrays before the main loop</span>
0036 backgs = zeros(numberOfContrasts,1);
0037 qzshifts = zeros(numberOfContrasts,1);
0038 scalefactors = zeros(numberOfContrasts,1);
0039 bulkIns = zeros(numberOfContrasts,1);
0040 bulkOuts = zeros(numberOfContrasts,1);
0041 resols = zeros(numberOfContrasts,1);
0042 allRoughs = zeros(numberOfContrasts,1);
0043 outSsubs = zeros(numberOfContrasts,1);
0044 chis =  zeros(numberOfContrasts,1);
0045 layerSlds = cell(numberOfContrasts,2);
0046 domainSldProfiles = cell(numberOfContrasts,2);
0047 shifted_data = cell(numberOfContrasts,1);
0048 
0049 reflectivity = cell(numberOfContrasts,1);
0050 <span class="keyword">for</span> i = 1:numberOfContrasts
0051     reflectivity{i} = [1 1 ; 1 1];
0052 <span class="keyword">end</span>
0053 
0054 Simulation = cell(numberOfContrasts,1);
0055 <span class="keyword">for</span> i = 1:numberOfContrasts
0056     Simulation{i} = [1 1 ; 1 1];
0057 <span class="keyword">end</span>
0058 
0059 allLayers = cell(numberOfContrasts,2);
0060 <span class="keyword">for</span> i = 1:numberOfContrasts
0061     allLayers{i,1} = [1 1 1; 1 1 1];
0062     allLayers{i,2} = [1 1 1; 1 1 1];
0063 <span class="keyword">end</span>
0064 
0065 tempSldProfiles = cell(numberOfContrasts,1);
0066 <span class="keyword">for</span> i = 1:numberOfContrasts
0067     tempSldProfiles{i} = {[1 1 ; 1 1],[1 1 ; 1 1]};
0068 <span class="keyword">end</span>
0069 
0070 calcAllLayers = cell(numberOfContrasts,2);
0071 <span class="keyword">for</span> i = 1:numberOfContrasts
0072     calcAllLayers{i,1} = [1 ; 1];
0073     calcAllLayers{i,2} = [1 ; 1];
0074 <span class="keyword">end</span>
0075 
0076 tempAllLayers = cell(numberOfContrasts,1);
0077 <span class="keyword">for</span> i = 1:numberOfContrasts
0078     tempAllLayers{i} = {[1 1 1;1 1 1],[1 1 1;1 1 1]};
0079 <span class="keyword">end</span>
0080 
0081 tempLayerSlds = cell(numberOfContrasts,1);
0082 <span class="keyword">for</span> i = 1:numberOfContrasts
0083     tempLayerSlds{i} = {[1 1 1;1 1 1],[1 1 1;1 1 1]};
0084 <span class="keyword">end</span>
0085 <span class="comment">% end memory allocation.</span>
0086 
0087 <span class="comment">% First we need to allocate the absolute values of the input</span>
0088 <span class="comment">% parameters to all the layers in the layers list. This only needs</span>
0089 <span class="comment">% to be done once, and so is done outside the contrasts loop</span>
0090 outParameterisedLayers = <a href="../../../targetFunctions/common/groupLayers/allocateParamsToLayers.html" class="code" title="function outLayers = allocateParamsToLayers(params, layersDetails)">allocateParamsToLayers</a>(params, layersDetails);
0091 
0092 <span class="comment">% Resample params if requiired</span>
0093 resamPars = controls.resamPars;
0094 
0095 <span class="comment">% Loop over all the contrasts</span>
0096 <span class="keyword">for</span> i = 1:numberOfContrasts
0097 
0098     <span class="comment">% Get the domain ratio for this contrast</span>
0099     thisContrastDR = contrastDomainRatios(i);
0100     <span class="keyword">if</span> isempty(thisContrastDR)
0101         thisContrastDR = 1;
0102     <span class="keyword">end</span>
0103     domainRatio = allDomainRatios(thisContrastDR);
0104 
0105     <span class="comment">% Extract the relevant parameter values for this contrast</span>
0106     <span class="comment">% from the input arrays.</span>
0107     <span class="comment">% First need to decide which values of the backgrounds, scalefactors</span>
0108     <span class="comment">% data shifts and bulk contrasts are associated with this contrast</span>
0109     [thisBackground,thisQzshift,thisScalefactor,thisBulkIn,thisBulkOut,thisResol] = <a href="../../../targetFunctions/common/backSort.html" class="code" title="function [outBackground,outQzshift,outScalefactor,outBulkIn,outBulkOut,outResolution] = backSort(contrastBackgrounds,contrastQzshifts,contrastScalefactors,contrastBulkIns,contrastBulkOuts,contrastResolutions,backs,qzshifts,scalefactor,bulkIn,bulkOut,res)">backSort</a>(contrastBackgrounds(i),contrastQzshifts(i),contrastScalefactors(i),contrastBulkIns(i),contrastBulkOuts(i),contrastResolutions(i),backs,shifts,scalefactor,bulkIn,bulkOut,res);
0110     
0111     <span class="comment">% Also need to determine which layers from the overall layers list</span>
0112     <span class="comment">% are required for this contrast, and put them in the correct order</span>
0113     <span class="comment">% according to geometry. We run it twice, once for each domain...</span>
0114     thisContrastLayers1 = <a href="../../../targetFunctions/common/groupLayers/allocateLayersForContrast.html" class="code" title="function     thisContrastLayers = allocateLayersForContrast(contrastLayers,outParameterisedLayers,useImaginary)">allocateLayersForContrast</a>(domainContrastLayers{1},outParameterisedLayers,useImaginary);
0115     thisContrastLayers2 = <a href="../../../targetFunctions/common/groupLayers/allocateLayersForContrast.html" class="code" title="function     thisContrastLayers = allocateLayersForContrast(contrastLayers,outParameterisedLayers,useImaginary)">allocateLayersForContrast</a>(domainContrastLayers{2},outParameterisedLayers,useImaginary);
0116     
0117     <span class="comment">% For the other parameters, we extract the correct ones from the input</span>
0118     <span class="comment">% arrays</span>
0119     thisRough = params(1);      <span class="comment">% Substrate roughness is always first parameter for standard layers</span>
0120     thisRepeatLayers = repeatLayers{i};
0121     thisResample = resample(i);
0122     thisData = allData{i};
0123     thisDataPresent = dataPresent(i);
0124     thisDataLimits = dataLimits{i};
0125     thisSimLimits = simLimits{i};
0126     thisBacksType = backsType(i);
0127     
0128     <span class="comment">% Now call the core layers reflectivity calculation</span>
0129     <span class="comment">% In this case we are single cored, so we do not parallelise over</span>
0130     <span class="comment">% points</span>
0131     <a href="parallelPoints.html" class="code" title="function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,domainSldProfiles,allLayers,allRoughs] = parallelPoints(problemDef,problemDefCells,controls)">parallelPoints</a> = <span class="string">'points'</span>;
0132     
0133     <span class="comment">% Call the core layers calculation - need to do this once for each</span>
0134     <span class="comment">% domain</span>
0135     [sldProfile1,reflect1,Simul1,shifted_dat,layerSld1,resamLayers1,~,thisSsubs]= nonPolarisedTF.coreLayersCalculation(thisContrastLayers1, thisRough, <span class="keyword">...</span>
0136     geometry, thisBulkIn, thisBulkOut, thisResample, calcSld, thisScalefactor, thisQzshift,<span class="keyword">...</span>
0137     thisDataPresent, thisData, thisDataLimits, thisSimLimits, thisRepeatLayers,<span class="keyword">...</span>
0138     thisBackground,thisResol,thisBacksType,nParams,<a href="parallelPoints.html" class="code" title="function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,domainSldProfiles,allLayers,allRoughs] = parallelPoints(problemDef,problemDefCells,controls)">parallelPoints</a>,resamPars,useImaginary);
0139 
0140     [sldProfile2,reflect2,Simul2,~,layerSld2,resamLayers2,~,~] = nonPolarisedTF.coreLayersCalculation(thisContrastLayers2, thisRough, <span class="keyword">...</span>
0141     geometry, thisBulkIn, thisBulkOut, thisResample, calcSld, thisScalefactor, thisQzshift,<span class="keyword">...</span>
0142     thisDataPresent, thisData, thisDataLimits, thisSimLimits, thisRepeatLayers,<span class="keyword">...</span>
0143     thisBackground,thisResol,thisBacksType,nParams,<a href="parallelPoints.html" class="code" title="function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,domainSldProfiles,allLayers,allRoughs] = parallelPoints(problemDef,problemDefCells,controls)">parallelPoints</a>,resamPars,useImaginary);
0144 
0145     <span class="comment">% Calculate the average reflectivities....</span>
0146     [totReflect,totSimul] = domainsTF.averageReflectivity(reflect1,reflect2,Simul1,Simul2,domainRatio);
0147 
0148     <span class="comment">% Get an overall chi-squared for the new averaged curve..</span>
0149     thisChiSquared = <a href="../../../targetFunctions/common/costFunctions/chiSquared.html" class="code" title="function chi2 = chiSquared(thisData,thisFit,P)">chiSquared</a>(shifted_dat,totReflect,length(params));
0150 
0151     <span class="comment">% Store returned values for this contrast in the output arrays.</span>
0152     <span class="comment">% As well as the calculated profiles, we also store a record of</span>
0153     <span class="comment">% the other values (background, scalefactors etc) for each contrast</span>
0154     <span class="comment">% for future use.</span>
0155     outSsubs(i) = thisSsubs;
0156     tempSldProfiles{i} = {sldProfile1, sldProfile2};
0157     reflectivity{i} = totReflect;
0158     Simulation{i} = totSimul;
0159     shifted_data{i} = shifted_dat;
0160     tempLayerSlds{i} = {layerSld1, layerSld2};
0161     tempAllLayers{i} = {resamLayers1, resamLayers2};
0162     
0163     chis(i) = thisChiSquared;
0164     backgs(i) = thisBackground;
0165     qzshifts(i) = thisQzshift;
0166     scalefactors(i) = thisScalefactor;
0167     bulkIns(i) = thisBulkIn;
0168     bulkOuts(i) = thisBulkOut;
0169     resols(i) = thisResol;
0170     allRoughs(i) = thisRough;
0171 <span class="keyword">end</span>
0172 
0173 <span class="keyword">for</span> i = 1:numberOfContrasts
0174     theseDomainSLDs = tempSldProfiles{i};
0175     domainSldProfiles{i,1} = theseDomainSLDs{1};
0176     domainSldProfiles{i,2} = theseDomainSLDs{2};
0177 
0178     theseAllLayers = tempAllLayers{i};
0179     allLayers{i,1} = theseAllLayers{1};
0180     allLayers{i,2} = theseAllLayers{2};
0181 
0182     theseLayerSlds = tempLayerSlds{i};
0183     layerSlds{i,1} = theseLayerSlds{1};
0184     layerSlds{i,2} = theseLayerSlds{2};
0185 <span class="keyword">end</span>
0186 <span class="keyword">end</span>
</pre></div>

<hr><address>Generated on Mon 04-Dec-2023 13:09:56 by <strong><a href="https://github.com/gllmflndn/m2html">m2html</a></strong> &copy; 2003-2022</address>
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of reflectivityCalculation</title>
  <meta name="keywords" content="reflectivityCalculation">
  <meta name="description" content="Main function for the domainsTF reflectivity calculation.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003-2019 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../menu.html targetFunctions -->
<!-- menu.html +domainsTF -->

<h1>reflectivityCalculation
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Main function for the domainsTF reflectivity calculation.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [contrastParams,calculationResults,reflectivity,simulation,shiftedData,layerSlds,sldProfiles,resampledLayers] = reflectivityCalculation(problemStruct,problemCells,controls) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Main function for the domainsTF reflectivity calculation.
 This function decides what type of model is being analysed and branches
 to the correct one. The main options are:

 Standard Layers   - This is the equivalent of Standard Layers in RasCAL.
 Custom Layers     - This is also a layers calculation, but the
                     specification of the layers is done using a user
                     defined function.
 Custom XY         - This also has a model described by a user supplied
                     function, but in this case the function generates an    
                     SLD profile (i.e. XY function) rather than a list of
                     layers.

 We then decide on parallelisation options before calling the relevant
 version of the main custom layers calculation. It is more efficient to
 have multiple versions of the core calculation, each dealing with a
 different scheme for parallelisation. These are:

 single            - single threaded reflectivity calculation.
 points            - parallelise over points.
 contrasts         - parallelise over contrasts.

</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../API/RATMain.html" class="code" title="function [problemStruct,result,bayesResults] = RATMain(problemStruct,problemCells,problemLimits,controls,priors)">RATMain</a>	</li>
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [contrastParams,calculationResults,reflectivity,simulation,shiftedData,layerSlds,sldProfiles,resampledLayers] = reflectivityCalculation(problemStruct,problemCells,controls)</a>
0002 
0003 <span class="comment">% Main function for the domainsTF reflectivity calculation.</span>
0004 <span class="comment">% This function decides what type of model is being analysed and branches</span>
0005 <span class="comment">% to the correct one. The main options are:</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% Standard Layers   - This is the equivalent of Standard Layers in RasCAL.</span>
0008 <span class="comment">% Custom Layers     - This is also a layers calculation, but the</span>
0009 <span class="comment">%                     specification of the layers is done using a user</span>
0010 <span class="comment">%                     defined function.</span>
0011 <span class="comment">% Custom XY         - This also has a model described by a user supplied</span>
0012 <span class="comment">%                     function, but in this case the function generates an</span>
0013 <span class="comment">%                     SLD profile (i.e. XY function) rather than a list of</span>
0014 <span class="comment">%                     layers.</span>
0015 <span class="comment">%</span>
0016 <span class="comment">% We then decide on parallelisation options before calling the relevant</span>
0017 <span class="comment">% version of the main custom layers calculation. It is more efficient to</span>
0018 <span class="comment">% have multiple versions of the core calculation, each dealing with a</span>
0019 <span class="comment">% different scheme for parallelisation. These are:</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% single            - single threaded reflectivity calculation.</span>
0022 <span class="comment">% points            - parallelise over points.</span>
0023 <span class="comment">% contrasts         - parallelise over contrasts.</span>
0024 <span class="comment">%</span>
0025 
0026 <span class="comment">% Find out the model type from the input structs</span>
0027 type = problemStruct.modelType;
0028 numberOfContrasts = problemStruct.numberOfContrasts;
0029 
0030 <span class="comment">% Pre-allocation - It's necessary to pre-define the types for all the</span>
0031 <span class="comment">% arrays for compilation, so do this in this block.</span>
0032 backgroundParams = zeros(numberOfContrasts,1);
0033 qzshifts = zeros(numberOfContrasts,1);
0034 scalefactors = zeros(numberOfContrasts,1);
0035 bulkIns = zeros(numberOfContrasts,1);
0036 bulkOuts = zeros(numberOfContrasts,1);
0037 chis = zeros(numberOfContrasts,1);
0038 resolutionParams = zeros(numberOfContrasts,1);
0039 subRoughs = zeros(numberOfContrasts,1);
0040 
0041 <span class="comment">% Pre-allocate the output arrays.. this is necessary because otherwise the</span>
0042 <span class="comment">% compiler complains with 'Output argument &lt;....&gt; is not assigned on some</span>
0043 <span class="comment">% execution paths' error.</span>
0044 reflectivity = cell(numberOfContrasts,1);
0045 <span class="keyword">for</span> i = 1:numberOfContrasts
0046     reflectivity{i} = [1 1; 1 1];
0047 <span class="keyword">end</span>
0048 
0049 simulation = cell(numberOfContrasts,1);
0050 <span class="keyword">for</span> i = 1:numberOfContrasts
0051     simulation{i} = [1 1; 1 1];
0052 <span class="keyword">end</span>
0053 
0054 shiftedData = cell(numberOfContrasts,1);
0055 <span class="keyword">for</span> i = 1:numberOfContrasts
0056     shiftedData{i} = [1 1 1; 1 1 1];
0057 <span class="keyword">end</span>
0058 
0059 layerSlds = cell(numberOfContrasts,2);
0060 <span class="keyword">for</span> i = 1:numberOfContrasts
0061     layerSlds{i,1} = [1 1 1; 1 1 1];
0062     layerSlds{i,2} = [1 1 1; 1 1 1];
0063 <span class="keyword">end</span>
0064 
0065 sldProfiles = cell(numberOfContrasts,2);
0066 <span class="keyword">for</span> i = 1:numberOfContrasts
0067     sldProfiles{i,1} = [1 1; 1 1];
0068     sldProfiles{i,2} = [1 1; 1 1];
0069 <span class="keyword">end</span>
0070 
0071 resampledLayers = cell(numberOfContrasts,2);
0072 <span class="keyword">for</span> i = 1:numberOfContrasts
0073     resampledLayers{i,1} = [1 1 1; 1 1 1];
0074     resampledLayers{i,2} = [1 1 1; 1 1 1];
0075 <span class="keyword">end</span>
0076            
0077 <span class="keyword">switch</span> lower(type)
0078     <span class="keyword">case</span> coderEnums.modelTypes.StandardLayers
0079 
0080         [backgroundParams,qzshifts,scalefactors,bulkIns,bulkOuts,<span class="keyword">...</span>
0081          resolutionParams,chis,reflectivity,simulation,shiftedData,<span class="keyword">...</span>
0082          layerSlds,sldProfiles,resampledLayers,<span class="keyword">...</span>
0083          subRoughs] = domainsTF.standardLayers(problemStruct,problemCells,controls);        
0084 
0085     <span class="keyword">case</span> coderEnums.modelTypes.CustomLayers
0086 
0087         [backgroundParams,qzshifts,scalefactors,bulkIns,bulkOuts,<span class="keyword">...</span>
0088          resolutionParams,chis,reflectivity,simulation,shiftedData,<span class="keyword">...</span>
0089          layerSlds,sldProfiles,resampledLayers,<span class="keyword">...</span>
0090          subRoughs] = domainsTF.customLayers(problemStruct,problemCells,controls);
0091 
0092     <span class="keyword">case</span> coderEnums.modelTypes.CustomXY
0093 
0094         [backgroundParams,qzshifts,scalefactors,bulkIns,bulkOuts,<span class="keyword">...</span>
0095          resolutionParams,chis,reflectivity,simulation,shiftedData,<span class="keyword">...</span>
0096          layerSlds,sldProfiles,resampledLayers,<span class="keyword">...</span>
0097          subRoughs] = domainsTF.customXY(problemStruct,problemCells,controls);
0098 
0099 <span class="keyword">end</span>
0100 
0101 <span class="comment">% Package everything into one array for tidy output</span>
0102 contrastParams.backgroundParams = backgroundParams;
0103 contrastParams.qzshifts = qzshifts;
0104 contrastParams.scalefactors = scalefactors;
0105 contrastParams.bulkIn = bulkIns;
0106 contrastParams.bulkOut = bulkOuts;
0107 contrastParams.resolutionParams = resolutionParams;
0108 contrastParams.subRoughs = subRoughs;
0109 contrastParams.resample = problemStruct.resample;
0110 
0111 calculationResults.chiValues = chis;
0112 calculationResults.sumChi = sum(chis);
0113 
0114 <span class="keyword">end</span>
</pre></div>

<hr><address>Generated on Tue 09-Apr-2024 08:31:11 by <strong><a href="https://github.com/gllmflndn/m2html">m2html</a></strong> &copy; 2003-2022</address>
</body>
</html>

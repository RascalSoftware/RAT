<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of single</title>
  <meta name="keywords" content="single">
  <meta name="description" content="Single threaded version of the Standard Layers calculation">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003-2019 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../../menu.html targetFunctions -->
<!-- ../menu.html +nonPolarisedTF -->
<!-- menu.html +standardLayers -->

<h1>single
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>Single threaded version of the Standard Layers calculation</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,sldProfiles,allLayers,allRoughs] = single(problemDef,problemDefCells,controls) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Single threaded version of the Standard Layers calculation 
 This is the main reflectivity calculation of the standard layers
 calculation type. It extracts the required parameters for the contrasts
 from the input arrays, then passes the main calculation to
 'standardLayersCore', which carries out the calculation itself. 
 The core calculation is common for both standard and custom layers.
</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../targetFunctions/+domainsTF/+customLayers/parallelPoints.html" class="code" title="function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,domainSldProfiles,allLayers,allRoughs] = parallelPoints(problemDef,problemDefCells,controls)">parallelPoints</a>	Single threaded version of the custom layers, domainsTF reflectivity</li>
<li><a href="../../../targetFunctions/+domainsTF/+customXY/parallelPoints.html" class="code" title="function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,domainSldProfiles,allLayers,allRoughs] = parallelPoints(problemDef,problemDefCells,controls)">parallelPoints</a>	Extract individual cell arrays</li>
<li><a href="../../../targetFunctions/+domainsTF/+standardLayers/parallelPoints.html" class="code" title="function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,domainSldProfiles,allLayers,allRoughs] = parallelPoints(problemDef,problemDefCells,controls)">parallelPoints</a>	Single threaded version of the Standard Layers calculation</li>
<li><a href="../../../targetFunctions/+nonPolarisedTF/+customLayers/parallelPoints.html" class="code" title="function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,sldProfiles,allLayers,allRoughs] = parallelPoints(problemDef,problemDefCells,controls)">parallelPoints</a>	Multi threaded version of the custom layers over reflectivity poimnts</li>
<li><a href="../../../targetFunctions/+nonPolarisedTF/+customXY/parallelPoints.html" class="code" title="function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,sldProfiles,allLayers,allRoughs] = parallelPoints(problemDef,problemDefCells,controls)">parallelPoints</a>	Multi threaded version of the custom XY profile over reflectivity points</li>
<li><a href="parallelPoints.html" class="code" title="function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,sldProfiles,allLayers,allRoughs] = parallelPoints(problemDef,problemDefCells,controls)">parallelPoints</a>	Standard Layers calculation paralelised over the inner loop</li>
<li><a href="../../../targetFunctions/common/backSort.html" class="code" title="function [outBackground,outQzshift,outScalefactor,outBulkIn,outBulkOut,outResolution] = backSort(contrastBackgrounds,contrastQzshifts,contrastScalefactors,contrastBulkIns,contrastBulkOuts,contrastResolutions,backs,qzshifts,scalefactor,bulkIn,bulkOut,res)">backSort</a>	Distributes the background and shift values among the different contrasts</li>
<li><a href="../../../targetFunctions/common/extractProblemParams.html" class="code" title="function [numberOfContrasts, geometry, contrastBackgrounds, contrastQzshifts, contrastScalefactors, contrastBulkIns, contrastBulkOuts,contrastResolutions, backs, shifts, scalefactor, bulkIn, bulkOut, res, dataPresent, nParams, params,numberOfLayers, resample, backsType, contrastCustomFiles] =  extractProblemParams(problemDef)">extractProblemParams</a>	Extract individual parameters from problemDef</li>
<li><a href="../../../targetFunctions/common/groupLayers/allocateLayersForContrast.html" class="code" title="function     thisContrastLayers = allocateLayersForContrast(contrastLayers,outParameterisedLayers,useImaginary)">allocateLayersForContrast</a>	Decide which layers are needed for a particular contrast.</li>
<li><a href="../../../targetFunctions/common/groupLayers/allocateParamsToLayers.html" class="code" title="function outLayers = allocateParamsToLayers(params, layersDetails)">allocateParamsToLayers</a>	Allocates parameters from the parameter array to the correct layers</li>
<li><a href="../../../targetFunctions/common/parseCells.html" class="code" title="function [repeatLayers,allData,dataLimits,simLimits,contrastLayers,layersDetails,customFiles] = parseCells(problemDefCells)">parseCells</a>	Splits up the master input list of all arrays into separate arrays</li>
</ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 
0002 <a name="_sub0" href="#_subfunctions" class="code">function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,</a><span class="keyword">...</span>
0003     Simulation,shifted_data,layerSlds,sldProfiles,allLayers,<span class="keyword">...</span>
0004     allRoughs] = single(problemDef,problemDefCells,controls)
0005 <span class="comment">% Single threaded version of the Standard Layers calculation</span>
0006 <span class="comment">% This is the main reflectivity calculation of the standard layers</span>
0007 <span class="comment">% calculation type. It extracts the required parameters for the contrasts</span>
0008 <span class="comment">% from the input arrays, then passes the main calculation to</span>
0009 <span class="comment">% 'standardLayersCore', which carries out the calculation itself.</span>
0010 <span class="comment">% The core calculation is common for both standard and custom layers.</span>
0011 
0012 
0013 <span class="comment">% Extract individual cell arrays</span>
0014 [repeatLayers,<span class="keyword">...</span>
0015  allData,<span class="keyword">...</span>
0016  dataLimits,<span class="keyword">...</span>
0017  simLimits,<span class="keyword">...</span>
0018  contrastLayers,<span class="keyword">...</span>
0019  layersDetails,~] = <a href="../../../targetFunctions/common/parseCells.html" class="code" title="function [repeatLayers,allData,dataLimits,simLimits,contrastLayers,layersDetails,customFiles] = parseCells(problemDefCells)">parseCells</a>(problemDefCells);
0020 
0021 <span class="comment">% Extract individual parameters from problemDef struct</span>
0022 [numberOfContrasts, geometry, contrastBackgrounds, contrastQzshifts, contrastScalefactors, contrastBulkIns, contrastBulkOuts,<span class="keyword">...</span>
0023 contrastResolutions, backs, shifts, scalefactor, bulkIn, bulkOut, res, dataPresent, nParams, params,<span class="keyword">...</span>
0024 ~, resample, backsType, ~] =  <a href="../../../targetFunctions/common/extractProblemParams.html" class="code" title="function [numberOfContrasts, geometry, contrastBackgrounds, contrastQzshifts, contrastScalefactors, contrastBulkIns, contrastBulkOuts,contrastResolutions, backs, shifts, scalefactor, bulkIn, bulkOut, res, dataPresent, nParams, params,numberOfLayers, resample, backsType, contrastCustomFiles] =  extractProblemParams(problemDef)">extractProblemParams</a>(problemDef);
0025 
0026 calcSld = controls.calcSldDuringFit;   
0027 useImaginary = problemDef.useImaginary;
0028 
0029 <span class="comment">% Allocate the memory for the output arrays before the main loop</span>
0030 backgs = zeros(numberOfContrasts,1);
0031 qzshifts = zeros(numberOfContrasts,1);
0032 scalefactors = zeros(numberOfContrasts,1);
0033 bulkIns = zeros(numberOfContrasts,1);
0034 bulkOuts = zeros(numberOfContrasts,1);
0035 resols = zeros(numberOfContrasts,1);
0036 allRoughs = zeros(numberOfContrasts,1);
0037 outSsubs = zeros(numberOfContrasts,1);
0038 chis =  zeros(numberOfContrasts,1);
0039 layerSlds = cell(numberOfContrasts,1);
0040 sldProfiles = cell(numberOfContrasts,1);
0041 shifted_data = cell(numberOfContrasts,1);
0042 
0043 reflectivity = cell(numberOfContrasts,1);
0044 <span class="keyword">for</span> i = 1:numberOfContrasts
0045     reflectivity{i} = [1 1 ; 1 1];
0046 <span class="keyword">end</span>
0047 
0048 Simulation = cell(numberOfContrasts,1);
0049 <span class="keyword">for</span> i = 1:numberOfContrasts
0050     Simulation{i} = [1 1 ; 1 1];
0051 <span class="keyword">end</span>
0052 
0053 allLayers = cell(numberOfContrasts,1);
0054 <span class="keyword">for</span> i = 1:numberOfContrasts
0055     allLayers{i} = [1 1 1; 1 1 1];
0056 <span class="keyword">end</span>
0057 <span class="comment">% end memory allocation.</span>
0058 
0059 
0060 <span class="comment">% First we need to allocate the absolute values of the input</span>
0061 <span class="comment">% parameters to all the layers in the layers list. This only needs</span>
0062 <span class="comment">% to be done once, and so is done outside the contrasts loop</span>
0063 outParameterisedLayers = <a href="../../../targetFunctions/common/groupLayers/allocateParamsToLayers.html" class="code" title="function outLayers = allocateParamsToLayers(params, layersDetails)">allocateParamsToLayers</a>(params, layersDetails);
0064 
0065 <span class="comment">% Resample params if requiired</span>
0066 resamPars = controls.resamPars;
0067 
0068 <span class="comment">% Loop over all the contrasts</span>
0069 <span class="keyword">for</span> i = 1:numberOfContrasts
0070     
0071     <span class="comment">% Extract the relevant parameter values for this contrast</span>
0072     <span class="comment">% from the input arrays.</span>
0073     <span class="comment">% First need to decide which values of the backgrounds, scalefactors</span>
0074     <span class="comment">% data shifts and bulk contrasts are associated with this contrast</span>
0075     [thisBackground,thisQzshift,thisScalefactor,thisBulkIn,thisBulkOut,thisResol] = <a href="../../../targetFunctions/common/backSort.html" class="code" title="function [outBackground,outQzshift,outScalefactor,outBulkIn,outBulkOut,outResolution] = backSort(contrastBackgrounds,contrastQzshifts,contrastScalefactors,contrastBulkIns,contrastBulkOuts,contrastResolutions,backs,qzshifts,scalefactor,bulkIn,bulkOut,res)">backSort</a>(contrastBackgrounds(i),contrastQzshifts(i),contrastScalefactors(i),contrastBulkIns(i),contrastBulkOuts(i),contrastResolutions(i),backs,shifts,scalefactor,bulkIn,bulkOut,res);
0076     
0077     <span class="comment">% Also need to determine which layers from the overall layers list</span>
0078     <span class="comment">% are required for this contrast, and put them in the correct order</span>
0079     <span class="comment">% according to geometry</span>
0080     thisContrastLayers = <a href="../../../targetFunctions/common/groupLayers/allocateLayersForContrast.html" class="code" title="function     thisContrastLayers = allocateLayersForContrast(contrastLayers,outParameterisedLayers,useImaginary)">allocateLayersForContrast</a>(contrastLayers{i},outParameterisedLayers,useImaginary);
0081     
0082     <span class="comment">% For the other parameters, we extract the correct ones from the input</span>
0083     <span class="comment">% arrays</span>
0084     thisRough = params(1);      <span class="comment">% Substrate roughness is always first parameter for standard layers</span>
0085     thisRepeatLayers = repeatLayers{i};
0086     thisResample = resample(i);
0087     thisData = allData{i};
0088     thisDataPresent = dataPresent(i);
0089     thisDataLimits = dataLimits{i};
0090     thisSimLimits = simLimits{i};
0091     thisBacksType = backsType(i);
0092     
0093     <span class="comment">% Now call the core layers reflectivity calculation</span>
0094     <span class="comment">% In this case we are single cored, so we do not parallelise over</span>
0095     <span class="comment">% points</span>
0096     <a href="parallelPoints.html" class="code" title="function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,sldProfiles,allLayers,allRoughs] = parallelPoints(problemDef,problemDefCells,controls)">parallelPoints</a> = <span class="string">'single'</span>;
0097     
0098     <span class="comment">% Call the core layers calculation</span>
0099     [sldProfile,reflect,Simul,shifted_dat,layerSld,resampledLayers,<span class="keyword">...</span>
0100         thisChiSquared,thisSsubs] = nonPolarisedTF.coreLayersCalculation(thisContrastLayers, thisRough, <span class="keyword">...</span>
0101     geometry, thisBulkIn, thisBulkOut, thisResample, calcSld, thisScalefactor, thisQzshift,<span class="keyword">...</span>
0102     thisDataPresent, thisData, thisDataLimits, thisSimLimits, thisRepeatLayers,<span class="keyword">...</span>
0103     thisBackground,thisResol,thisBacksType,nParams,<a href="parallelPoints.html" class="code" title="function [outSsubs,backgs,qzshifts,scalefactors,bulkIns,bulkOuts,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,sldProfiles,allLayers,allRoughs] = parallelPoints(problemDef,problemDefCells,controls)">parallelPoints</a>,resamPars,useImaginary);
0104    
0105     <span class="comment">% Store returned values for this contrast in the output arrays.</span>
0106     <span class="comment">% As well as the calculated profiles, we also store a record of</span>
0107     <span class="comment">% the other values (background, scalefactors etc) for each contrast</span>
0108     <span class="comment">% for future use.</span>
0109     outSsubs(i) = thisSsubs;
0110     sldProfiles{i} = sldProfile;
0111     reflectivity{i} = reflect;
0112     Simulation{i} = Simul;
0113     shifted_data{i} = shifted_dat;
0114     layerSlds{i} = layerSld;
0115     chis(i) = thisChiSquared;
0116     backgs(i) = thisBackground;
0117     qzshifts(i) = thisQzshift;
0118     scalefactors(i) = thisScalefactor;
0119     bulkIns(i) = thisBulkIn;
0120     bulkOuts(i) = thisBulkOut;
0121     resols(i) = thisResol;
0122     allRoughs(i) = thisRough;
0123     allLayers{i} = resampledLayers;
0124 <span class="keyword">end</span>
0125 <span class="keyword">end</span>
</pre></div>

<hr><address>Generated on Fri 01-Dec-2023 17:22:03 by <strong><a href="https://github.com/gllmflndn/m2html">m2html</a></strong> &copy; 2003-2022</address>
</body>
</html>

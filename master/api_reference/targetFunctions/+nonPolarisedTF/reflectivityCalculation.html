<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of reflectivityCalculation</title>
  <meta name="keywords" content="reflectivityCalculation">
  <meta name="description" content="Main function for the nonPolarisedTF reflectivity calculation.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003-2019 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../menu.html targetFunctions -->
<!-- menu.html +nonPolarisedTF -->

<h1>reflectivityCalculation
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Main function for the nonPolarisedTF reflectivity calculation.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [contrastParams,calculationResults,reflectivity,simulation,shiftedData,layerSlds,sldProfiles,resampledLayers] = reflectivityCalculation(problemStruct,problemCells,controls) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Main function for the nonPolarisedTF reflectivity calculation.
 This function decides what type of model is being analysed and branches
 to the correct one. The main options are:

 Standard Layers   - This is the equivalent of Standard Layers in RasCAL.
 Custom Layers     - This is also a layers calculation, but the
                     specification of the layers is done using a user
                     defined function.
 Custom XY         - This also has a model described by a user supplied
                     function, but in this case the function generates an    
                     SLD profile (i.e. XY function) rather than a list of
                     layers.

 We then decide on parallelisation options before calling the relevant
 version of the main custom layers calculation. It is more efficient to
 have multiple versions of the core calculation, each dealing with a
 different scheme for parallelisation. These are:

 single            - single threaded reflectivity calculation.
 points            - parallelise over points.
 contrasts         - parallelise over contrasts.

</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../API/RATMain.html" class="code" title="function [problemStruct,result,bayesResults] = RATMain(problemStruct,problemCells,problemLimits,controls,priors)">RATMain</a>	</li>
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [contrastParams,calculationResults,reflectivity,simulation,shiftedData,layerSlds,sldProfiles,resampledLayers] = reflectivityCalculation(problemStruct,problemCells,controls)</a>
0002 
0003 <span class="comment">% Main function for the nonPolarisedTF reflectivity calculation.</span>
0004 <span class="comment">% This function decides what type of model is being analysed and branches</span>
0005 <span class="comment">% to the correct one. The main options are:</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% Standard Layers   - This is the equivalent of Standard Layers in RasCAL.</span>
0008 <span class="comment">% Custom Layers     - This is also a layers calculation, but the</span>
0009 <span class="comment">%                     specification of the layers is done using a user</span>
0010 <span class="comment">%                     defined function.</span>
0011 <span class="comment">% Custom XY         - This also has a model described by a user supplied</span>
0012 <span class="comment">%                     function, but in this case the function generates an</span>
0013 <span class="comment">%                     SLD profile (i.e. XY function) rather than a list of</span>
0014 <span class="comment">%                     layers.</span>
0015 <span class="comment">%</span>
0016 <span class="comment">% We then decide on parallelisation options before calling the relevant</span>
0017 <span class="comment">% version of the main custom layers calculation. It is more efficient to</span>
0018 <span class="comment">% have multiple versions of the core calculation, each dealing with a</span>
0019 <span class="comment">% different scheme for parallelisation. These are:</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% single            - single threaded reflectivity calculation.</span>
0022 <span class="comment">% points            - parallelise over points.</span>
0023 <span class="comment">% contrasts         - parallelise over contrasts.</span>
0024 <span class="comment">%</span>
0025 
0026 <span class="comment">% Find out the model type from the input structs</span>
0027 type = problemStruct.modelType;
0028 numberOfContrasts = problemStruct.numberOfContrasts;
0029 
0030 <span class="comment">% Pre-allocation - It's necessary to pre-define the types for all the</span>
0031 <span class="comment">% arrays for compilation, so do this in this block.</span>
0032 backgroundParams = zeros(numberOfContrasts,1);
0033 qzshifts = zeros(numberOfContrasts,1);
0034 scalefactors = zeros(numberOfContrasts,1);
0035 bulkIns = zeros(numberOfContrasts,1);
0036 bulkOuts = zeros(numberOfContrasts,1);
0037 chis = zeros(numberOfContrasts,1);
0038 resolutionParams = zeros(numberOfContrasts,1);
0039 subRoughs = zeros(numberOfContrasts,1);
0040 
0041 <span class="comment">% Pre-allocate the output arrays. This is necessary because otherwise the</span>
0042 <span class="comment">% compiler complains with 'Output argument &lt;....&gt; is not assigned on some</span>
0043 <span class="comment">% execution paths' error.</span>
0044 reflectivity = cell(numberOfContrasts,1);
0045 <span class="keyword">for</span> i = 1:numberOfContrasts
0046     reflectivity{i} = [1 1; 1 1];
0047 <span class="keyword">end</span>
0048 
0049 simulation = cell(numberOfContrasts,1);
0050 <span class="keyword">for</span> i = 1:numberOfContrasts
0051     simulation{i} = [1 1; 1 1];
0052 <span class="keyword">end</span>
0053 
0054 shiftedData = cell(numberOfContrasts,1);
0055 <span class="keyword">for</span> i = 1:numberOfContrasts
0056     shiftedData{i} = [1 1 1; 1 1 1];
0057 <span class="keyword">end</span>
0058 
0059 layerSlds = cell(numberOfContrasts,1);
0060 <span class="keyword">for</span> i = 1:numberOfContrasts
0061     layerSlds{i} = [1 1 1; 1 1 1];
0062 <span class="keyword">end</span>
0063 
0064 sldProfiles = cell(numberOfContrasts,1);
0065 <span class="keyword">for</span> i = 1:numberOfContrasts
0066     sldProfiles{i} = [1 1; 1 1];
0067 <span class="keyword">end</span>
0068 
0069 resampledLayers = cell(numberOfContrasts,1);
0070 <span class="keyword">for</span> i = 1:numberOfContrasts
0071     resampledLayers{i} = [1 1 1; 1 1 1];
0072 <span class="keyword">end</span>
0073            
0074 <span class="keyword">switch</span> lower(type)
0075     <span class="keyword">case</span> coderEnums.modelTypes.StandardLayers
0076 
0077         [backgroundParams,qzshifts,scalefactors,bulkIns,bulkOuts,<span class="keyword">...</span>
0078          resolutionParams,chis,reflectivity,simulation,shiftedData,<span class="keyword">...</span>
0079          layerSlds,sldProfiles,resampledLayers,<span class="keyword">...</span>
0080          subRoughs] = nonPolarisedTF.standardLayers(problemStruct,problemCells,controls);
0081 
0082     <span class="keyword">case</span> coderEnums.modelTypes.CustomLayers
0083 
0084         [backgroundParams,qzshifts,scalefactors,bulkIns,bulkOuts,<span class="keyword">...</span>
0085          resolutionParams,chis,reflectivity,simulation,shiftedData,<span class="keyword">...</span>
0086          layerSlds,sldProfiles,resampledLayers,<span class="keyword">...</span>
0087          subRoughs] = nonPolarisedTF.customLayers(problemStruct,problemCells,controls);
0088 
0089     <span class="keyword">case</span> coderEnums.modelTypes.CustomXY
0090         
0091         [backgroundParams,qzshifts,scalefactors,bulkIns,bulkOuts,<span class="keyword">...</span>
0092          resolutionParams,chis,reflectivity,simulation,shiftedData,<span class="keyword">...</span>
0093          layerSlds,sldProfiles,resampledLayers,<span class="keyword">...</span>
0094          subRoughs] = nonPolarisedTF.customXY(problemStruct,problemCells,controls);
0095     <span class="keyword">otherwise</span>
0096         error(<span class="string">'The model type &quot;%s&quot; is not supported'</span>, type);
0097 <span class="keyword">end</span>
0098 
0099 <span class="comment">% Package everything into structs for tidy output</span>
0100 contrastParams.backgroundParams = backgroundParams;
0101 contrastParams.scalefactors = scalefactors;
0102 contrastParams.bulkIn = bulkIns;
0103 contrastParams.bulkOut = bulkOuts;
0104 contrastParams.resolutionParams = resolutionParams;
0105 contrastParams.subRoughs = subRoughs;
0106 contrastParams.resample = problemStruct.resample;
0107 
0108 calculationResults.chiValues = chis;
0109 calculationResults.sumChi = sum(chis);
0110 
0111 <span class="keyword">end</span>
</pre></div>

<hr><address>Generated on Mon 03-Jun-2024 10:39:54 by <strong><a href="https://github.com/gllmflndn/m2html">m2html</a></strong> &copy; 2003-2022</address>
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of abelesSingle</title>
  <meta name="keywords" content="abelesSingle">
  <meta name="description" content="New Matlab version of reflectivity">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003-2019 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../../../menu.html targetFunctions -->
<!-- ../../menu.html common -->
<!-- # reflectivityCalculations -->
<!-- menu.html abeles -->

<h1>abelesSingle
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>New Matlab version of reflectivity</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>function ref = abelesSingle(q,N,layers_thick,layers_rho,layers_sig) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> New Matlab version of reflectivity
 with complex rho...
</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="../../../../targetFunctions/common/callReflectivity/callReflectivity.html" class="code" title="function [reflectivity, simulation] = callReflectivity(bulkIns,bulkOuts,simLimits,repeatLayers,thisData,layers,ssubs,resolution,parallel,refType,useImaginary)">callReflectivity</a>	</li>
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function kn = findkn(k0,sld)</a></li>
<li><a href="#_sub2" class="code">function y = sqrtbc(theta,zarg)</a></li>
</ul>


<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function ref = abelesSingle(q,N,layers_thick,layers_rho,layers_sig)</a>
0002 
0003 <span class="comment">% New Matlab version of reflectivity</span>
0004 <span class="comment">% with complex rho...</span>
0005 
0006 <span class="comment">% Pre-allocation</span>
0007 tiny = 1e-30;
0008 ci = complex(0,1);
0009 c0 = complex(0,0);
0010 M_tot = [c0 c0 ; c0 c0];
0011 M_n = [c0 c0 ; c0 c0];
0012 M_res = [c0 c0 ; c0 c0];
0013 kn_ptr = c0;
0014 ref = zeros(length(q),1);
0015 
0016 <span class="keyword">for</span> points = 1:length(q)
0017 
0018     Q = q(points);
0019 
0020     <span class="keyword">if</span> isreal(layers_rho(1))
0021         bulk_in_SLD = complex(layers_rho(1),tiny);
0022     <span class="keyword">else</span>
0023         bulk_in_SLD = layers_rho(1);
0024         bulk_in_SLD = bulk_in_SLD + complex(0,tiny);
0025     <span class="keyword">end</span>
0026     k0 = Q/2;
0027 
0028     <span class="keyword">for</span> n = 1:N-1
0029 
0030         <span class="keyword">if</span> n == 1
0031 
0032             <span class="comment">% Find k1..</span>
0033             sld_1 = layers_rho(n+1) - bulk_in_SLD;
0034             k1 = <a href="#_sub1" class="code" title="subfunction kn = findkn(k0,sld)">findkn</a>(k0, sld_1);
0035 
0036             <span class="comment">% Find r01</span>
0037             nom1 = k0 - k1;
0038             denom1 = k0 + k1;
0039             sigmasqrd = layers_sig(n + 1) ^ 2;
0040             err1 = exp(-2 * k1 * k0 * sigmasqrd);
0041             r01 = (nom1 / denom1) * err1;
0042 
0043             <span class="comment">% Generate the M1 matrix:</span>
0044             M_tot(1,1) = complex(1,0);
0045             M_tot(1,2) = r01;
0046             M_tot(2,1) = r01;
0047             M_tot(2,2) = complex(1,0);
0048 
0049             kn_ptr = k1;
0050 
0051         <span class="keyword">else</span>
0052 
0053             <span class="comment">% Find kn and k_n+1 (ex. k1 and k2 for n=1): */</span>
0054             sld_np1 = layers_rho(n + 1);
0055             sld_np1 = sld_np1 - bulk_in_SLD;
0056 
0057             <span class="keyword">if</span> isreal(sld_np1)  <span class="comment">% This check may not be necessary</span>
0058                 sld_np1 = complex(sld_np1,eps);
0059             <span class="keyword">end</span>
0060 
0061             kn = kn_ptr;
0062             knp1 = <a href="#_sub1" class="code" title="subfunction kn = findkn(k0,sld)">findkn</a>(k0, sld_np1);
0063 
0064             <span class="comment">% Find r_n,n+1:</span>
0065             nom_n = kn - knp1;
0066             denom_n = kn + knp1;
0067             sigmasqrd = layers_sig(n + 1)^2;
0068             err_n = exp(-2 * kn * knp1 * sigmasqrd);
0069             r_n_np1 = (nom_n / denom_n) * err_n;
0070 
0071             <span class="comment">% Find the Phase Factor = (k_n * d_n)</span>
0072             beta = kn * layers_thick(n) * ci;
0073 
0074             <span class="comment">% Create the M_n matrix: */</span>
0075             M_n(1,1) = exp(beta);
0076             M_n(1,2) = r_n_np1 * exp(beta);
0077             M_n(2,1) = r_n_np1 * exp(-beta);
0078             M_n(2,2) = exp(-beta);
0079 
0080             <span class="comment">% Multiply the matrices</span>
0081             M_res = M_tot * M_n;
0082 
0083             <span class="comment">% Reassign the values back to M_tot:</span>
0084             M_tot = M_res;
0085 
0086             <span class="comment">% Point to k_n+1 and sld_n+1 via kn_ptr sld_n_ptr:</span>
0087             kn_ptr = knp1;
0088 
0089         <span class="keyword">end</span>
0090 
0091     <span class="keyword">end</span>
0092     R = abs(M_res(2,1)/M_res(1,1));
0093     ref(points) = R^2;
0094 <span class="keyword">end</span>
0095 
0096 <span class="keyword">end</span>
0097 
0098 <a name="_sub1" href="#_subfunctions" class="code">function kn = findkn(k0,sld)</a>
0099 
0100 subtr = k0^2 - 4 * pi * sld;
0101 kn = <a href="#_sub2" class="code" title="subfunction y = sqrtbc(theta,zarg)">sqrtbc</a>(pi/2,subtr);
0102 
0103 <span class="keyword">end</span>
0104 
0105 <a name="_sub2" href="#_subfunctions" class="code">function y = sqrtbc(theta,zarg)</a>
0106 <span class="comment">% sqrt function with branch cut in zarg from 0 to infinity along a ray</span>
0107 <span class="comment">% at angle theta (in radians) measured from the +x axis in the usual way,</span>
0108 <span class="comment">% with -pi&lt;=theta&lt;=pi.  theta = pi is the usual square root.</span>
0109 <span class="comment">% for zarg on the +x axis, sqrt behavior is conserved,</span>
0110 <span class="comment">% i.e. sqrtbc(theta,zarg) is positive and real for any theta.</span>
0111 <span class="comment">%</span>
0112 <span class="comment">% y = sqrtbc(theta,zarg)</span>
0113 <span class="keyword">if</span> theta==0
0114   phi = pi;
0115 <span class="keyword">else</span>
0116     phi = theta -pi*sign(theta);
0117 <span class="keyword">end</span>
0118 y = exp(i*phi/2)*sqrt(zarg*exp(-i*phi));
0119 <span class="comment">% translations:  sqrtbc(theta, z-b) has branch cut in the z plane from</span>
0120 <span class="comment">% branch point z = b out to infinity, along a ray at angle theta.</span>
0121 <span class="comment">%</span>
0122 <span class="comment">% for the usual square root with branch cut along -x,</span>
0123 <span class="comment">% the real part of sqrt(z) is positive (or 0) for all z.</span>
0124 <span class="comment">% for the modified square root with branch cut along +x,</span>
0125 <span class="comment">% the imaginary part of sqrt(z) is positive (or 0) for all z.</span>
0126 
0127 <span class="keyword">end</span>
0128 
0129 
0130 
</pre></div>

<hr><address>Generated on Tue 30-Apr-2024 15:28:34 by <strong><a href="https://github.com/gllmflndn/m2html">m2html</a></strong> &copy; 2003-2022</address>
</body>
</html>

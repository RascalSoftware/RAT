<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of adaptive</title>
  <meta name="keywords" content="adaptive">
  <meta name="description" content="% adaptive: evaluates a matlab function on a given range">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003-2019 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- # targetFunctions -->
<!-- # common -->
<!-- menu.html resampleLayers -->

<h1>adaptive
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>% adaptive: evaluates a matlab function on a given range</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function out = adaptive(sldProfile, startDomain, minAngle, nPoints) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">% adaptive: evaluates a matlab function on a given range

 'adaptive.m' allows to sample a function using a reduced number of
 points. It works iteratively adding new points where needed.
 It is especially useful for functions which are computationally intensive
 (e.g. involve solving a differential equation).

 Usage:
 XY = adaptive(func, [xstart, xend])
  evaluates 'func' in the range [xstart, xend]. Key-value arguments are
  used to control the function evaluation. If the function 'func' returns
  multiple output values, only the first one is used for the refinement
  process, but all of them are calculated and returned as additional
  columns in the output matrix. The output matrix XY contains the new
  domain points in the first column and the output values in the other
  columns.
 [x,yy] = adaptive(func, [xstart, xend])
   as before but separately returns the array with the domain points and
   the array/matrix with the function output values.
 [x,yy] = adaptive(func, xarray, ...)
   as before but explicitly provide an initial array of domain points.

 Methods:
   'adaptive' provides three methods for refining the function evaluation:
   1) add more points near the sharp corners, which are found by
    considering the triangles formed by three successive points and
    measuring the central angle.
   2) measure the area of the same triangles and add more points when the
    area is bigger than a threshold.
   3) measure the length of the segments formed by pairs of successive
    and split the segments which are longer than a threshold.
   If no methods is explicitly specified, the 'angle' method is used.

% Input parameters
  - func: input function (function handle)
  - initialDomain: initial domain points (1D array)

% Optional key-value input parameters
  - 'nPoints': (default 20)
       initial number of domain points, only used if an initial domain
       array is not excplitely provided.
  - 'maxRefinements': (default 10)
       Specifies the maximum number of refinement steps.
  - 'minAngle': (default 0.8*pi)
       Refine near the  points which forms, together with their left and right
       neighbours, a triangle with central angle smaller than a given value.
  - 'maxArea': (default 5e-4)
       Refine near the points which forms, together with their left and right
       neighbours, a triangle with area larger than a threshold. The threshold
       in normalized to the area enclosing th graph:
       threshold==maxArea*(max(x)-min(x))*(max(f(x))-min(f(x)))
  - 'maxLength': (default Inf)
       Refine all the sements which are longer than a given threshold. The
       threshold is relative to the input and output ranges. Specifically,
       before applying the threshold, the data are normalized so that
       max(x)-min(x)==1 and max(f(x))-min(f(x))==1.
  - 'minLength': (default 0)
       Exclude from the refinement process the segments which are shorter
       than a given threshold. The threshold is relative to the input and
       output ranges. Specifically, before applying the threshold, the
       data are normalized so that max(x)-min(x)==1 and max(f(x))-min(f(x))==1.
  - 'minSignal': (default 0.2)
       Exclude from the refinement process the points where the function is
       below a threshold. The threshold is relative to the output range: In
       this example threshold == 0.01*(max(f(x))-min(f(x))).
  - 'vectorizable': (default false)
       Specifies whether the input function accepts arrays as input
       (e.g. f(x)==x.^2).
  - 'waitbar': (default false)
       Display a waitbar.

 Output parameters
  - a NxM array where N is the number of domain points and M is the number
    of output parameters of the input function.


% Examples:

   % Refine a function near sharp corners. The option 'minAngle' is useful
   % for having more points near the peaks of the function.
   f = @(x) exp(-x.^2/4).*sin(3*x);
   % for test-purpose also evaluate the function directly
   x2 = -10:0.01:10;
   y2 = f(x2);
   y = adaptive(f, [-5,5], 'minAngle',0.8*pi);
   figure(1); plot(x2,f(x2),'k--',y(:,1),y(:,2),'o-');
   legend('high sampling','adaptive')
   title('y = adaptive(f, [xstart, xend], ''minAngle'',0.8*pi)')
   % as before but starting with an inital array of domain points
   x = -5:5;
   y = adaptive(f, x, 'minAngle',0.8*pi);
   figure(2); plot(x,f(x),'s-',x2,f(x2),'k--',y(:,1),y(:,2),'o-');
   legend('initial sampling','high sampling','adaptive')
   title('y = adaptive(f, x, ''minAngle'',0.8*pi)')

   % Refine a function near sharp corners, but do not split segments which
   % are already shorter than 'minLength'.
   y = adaptive(f, x, 'minAngle',0.8*pi, 'minLength',0.05);
   figure(3); plot(x,f(x),'s-',x2,f(x2),'k--',y(:,1),y(:,2),'o-');
   legend('initial sampling','high sampling','adaptive')
   title('y = adaptive(f, x, ''minAngle'',0.8*pi, ''minLength'',0.05)');

   % Refine a function until the areas of the triangles formed by
   % triplets of successive points are smaller than 'maxArea'.
   y = adaptive(f, x, 'maxArea',1e-3);
   figure(4); plot(x,f(x),'s-',x2,f(x2),'k--',y(:,1),y(:,2),'o-');
   legend('initial sampling','high sampling','adaptive')
   title('y = adaptive(f, x, ''maxArea'',1e-3)')

   % Refine a function until the segments formed by pairs of successive
   % points are shorter than 'maxLength'.
   y = adaptive(f, x, 'maxLength',0.1);
   figure(5); plot(x,f(x),'s-',x2,f(x2),'k--',y(:,1),y(:,2),'o-');
   legend('initial sampling','high sampling','adaptive')
   title('y = adaptive(f, x, ''maxLength'',0.1)');
</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="SLDFunction.html" class="code" title="function sldVal = SLDFunction(x,SLD)">SLDFunction</a>	sldVal = SLDFunction(x,SLD)</li>
</ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="resampleLayers.html" class="code" title="function newSLD = resampleLayers(sldProfile,resamPars)">resampleLayers</a>	Function handle for adaptive resampling</li>
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function y = normalizeFunction(x, sldProfile,vectorizable)</a></li>
<li><a href="#_sub2" class="code">function [firstStep,secondStep,longStep] = calculateTrianglesSides(XYdata)</a></li>
<li><a href="#_sub3" class="code">function cornerAngle = calculateCentralAngles(XYdata, dataBoxSize)</a></li>
<li><a href="#_sub4" class="code">function triangleArea = calculateTrianglesArea(XYdata)</a></li>
<li><a href="#_sub5" class="code">function dataPoints = increaseSampling(dataPoints, segmentsToSplit, sldProfile)</a></li>
</ul>


<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function out = adaptive(sldProfile, startDomain, minAngle, nPoints)</a>
0002 <span class="comment">%% adaptive: evaluates a matlab function on a given range</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% 'adaptive.m' allows to sample a function using a reduced number of</span>
0005 <span class="comment">% points. It works iteratively adding new points where needed.</span>
0006 <span class="comment">% It is especially useful for functions which are computationally intensive</span>
0007 <span class="comment">% (e.g. involve solving a differential equation).</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% Usage:</span>
0010 <span class="comment">% XY = adaptive(func, [xstart, xend])</span>
0011 <span class="comment">%  evaluates 'func' in the range [xstart, xend]. Key-value arguments are</span>
0012 <span class="comment">%  used to control the function evaluation. If the function 'func' returns</span>
0013 <span class="comment">%  multiple output values, only the first one is used for the refinement</span>
0014 <span class="comment">%  process, but all of them are calculated and returned as additional</span>
0015 <span class="comment">%  columns in the output matrix. The output matrix XY contains the new</span>
0016 <span class="comment">%  domain points in the first column and the output values in the other</span>
0017 <span class="comment">%  columns.</span>
0018 <span class="comment">% [x,yy] = adaptive(func, [xstart, xend])</span>
0019 <span class="comment">%   as before but separately returns the array with the domain points and</span>
0020 <span class="comment">%   the array/matrix with the function output values.</span>
0021 <span class="comment">% [x,yy] = adaptive(func, xarray, ...)</span>
0022 <span class="comment">%   as before but explicitly provide an initial array of domain points.</span>
0023 <span class="comment">%</span>
0024 <span class="comment">% Methods:</span>
0025 <span class="comment">%   'adaptive' provides three methods for refining the function evaluation:</span>
0026 <span class="comment">%   1) add more points near the sharp corners, which are found by</span>
0027 <span class="comment">%    considering the triangles formed by three successive points and</span>
0028 <span class="comment">%    measuring the central angle.</span>
0029 <span class="comment">%   2) measure the area of the same triangles and add more points when the</span>
0030 <span class="comment">%    area is bigger than a threshold.</span>
0031 <span class="comment">%   3) measure the length of the segments formed by pairs of successive</span>
0032 <span class="comment">%    and split the segments which are longer than a threshold.</span>
0033 <span class="comment">%   If no methods is explicitly specified, the 'angle' method is used.</span>
0034 <span class="comment">%</span>
0035 <span class="comment">%% Input parameters</span>
0036 <span class="comment">%  - func: input function (function handle)</span>
0037 <span class="comment">%  - initialDomain: initial domain points (1D array)</span>
0038 <span class="comment">%</span>
0039 <span class="comment">%% Optional key-value input parameters</span>
0040 <span class="comment">%  - 'nPoints': (default 20)</span>
0041 <span class="comment">%       initial number of domain points, only used if an initial domain</span>
0042 <span class="comment">%       array is not excplitely provided.</span>
0043 <span class="comment">%  - 'maxRefinements': (default 10)</span>
0044 <span class="comment">%       Specifies the maximum number of refinement steps.</span>
0045 <span class="comment">%  - 'minAngle': (default 0.8*pi)</span>
0046 <span class="comment">%       Refine near the  points which forms, together with their left and right</span>
0047 <span class="comment">%       neighbours, a triangle with central angle smaller than a given value.</span>
0048 <span class="comment">%  - 'maxArea': (default 5e-4)</span>
0049 <span class="comment">%       Refine near the points which forms, together with their left and right</span>
0050 <span class="comment">%       neighbours, a triangle with area larger than a threshold. The threshold</span>
0051 <span class="comment">%       in normalized to the area enclosing th graph:</span>
0052 <span class="comment">%       threshold==maxArea*(max(x)-min(x))*(max(f(x))-min(f(x)))</span>
0053 <span class="comment">%  - 'maxLength': (default Inf)</span>
0054 <span class="comment">%       Refine all the sements which are longer than a given threshold. The</span>
0055 <span class="comment">%       threshold is relative to the input and output ranges. Specifically,</span>
0056 <span class="comment">%       before applying the threshold, the data are normalized so that</span>
0057 <span class="comment">%       max(x)-min(x)==1 and max(f(x))-min(f(x))==1.</span>
0058 <span class="comment">%  - 'minLength': (default 0)</span>
0059 <span class="comment">%       Exclude from the refinement process the segments which are shorter</span>
0060 <span class="comment">%       than a given threshold. The threshold is relative to the input and</span>
0061 <span class="comment">%       output ranges. Specifically, before applying the threshold, the</span>
0062 <span class="comment">%       data are normalized so that max(x)-min(x)==1 and max(f(x))-min(f(x))==1.</span>
0063 <span class="comment">%  - 'minSignal': (default 0.2)</span>
0064 <span class="comment">%       Exclude from the refinement process the points where the function is</span>
0065 <span class="comment">%       below a threshold. The threshold is relative to the output range: In</span>
0066 <span class="comment">%       this example threshold == 0.01*(max(f(x))-min(f(x))).</span>
0067 <span class="comment">%  - 'vectorizable': (default false)</span>
0068 <span class="comment">%       Specifies whether the input function accepts arrays as input</span>
0069 <span class="comment">%       (e.g. f(x)==x.^2).</span>
0070 <span class="comment">%  - 'waitbar': (default false)</span>
0071 <span class="comment">%       Display a waitbar.</span>
0072 <span class="comment">%</span>
0073 <span class="comment">% Output parameters</span>
0074 <span class="comment">%  - a NxM array where N is the number of domain points and M is the number</span>
0075 <span class="comment">%    of output parameters of the input function.</span>
0076 <span class="comment">%</span>
0077 <span class="comment">%</span>
0078 <span class="comment">%% Examples:</span>
0079 <span class="comment">%</span>
0080 <span class="comment">%   % Refine a function near sharp corners. The option 'minAngle' is useful</span>
0081 <span class="comment">%   % for having more points near the peaks of the function.</span>
0082 <span class="comment">%   f = @(x) exp(-x.^2/4).*sin(3*x);</span>
0083 <span class="comment">%   % for test-purpose also evaluate the function directly</span>
0084 <span class="comment">%   x2 = -10:0.01:10;</span>
0085 <span class="comment">%   y2 = f(x2);</span>
0086 <span class="comment">%   y = adaptive(f, [-5,5], 'minAngle',0.8*pi);</span>
0087 <span class="comment">%   figure(1); plot(x2,f(x2),'k--',y(:,1),y(:,2),'o-');</span>
0088 <span class="comment">%   legend('high sampling','adaptive')</span>
0089 <span class="comment">%   title('y = adaptive(f, [xstart, xend], ''minAngle'',0.8*pi)')</span>
0090 <span class="comment">%   % as before but starting with an inital array of domain points</span>
0091 <span class="comment">%   x = -5:5;</span>
0092 <span class="comment">%   y = adaptive(f, x, 'minAngle',0.8*pi);</span>
0093 <span class="comment">%   figure(2); plot(x,f(x),'s-',x2,f(x2),'k--',y(:,1),y(:,2),'o-');</span>
0094 <span class="comment">%   legend('initial sampling','high sampling','adaptive')</span>
0095 <span class="comment">%   title('y = adaptive(f, x, ''minAngle'',0.8*pi)')</span>
0096 <span class="comment">%</span>
0097 <span class="comment">%   % Refine a function near sharp corners, but do not split segments which</span>
0098 <span class="comment">%   % are already shorter than 'minLength'.</span>
0099 <span class="comment">%   y = adaptive(f, x, 'minAngle',0.8*pi, 'minLength',0.05);</span>
0100 <span class="comment">%   figure(3); plot(x,f(x),'s-',x2,f(x2),'k--',y(:,1),y(:,2),'o-');</span>
0101 <span class="comment">%   legend('initial sampling','high sampling','adaptive')</span>
0102 <span class="comment">%   title('y = adaptive(f, x, ''minAngle'',0.8*pi, ''minLength'',0.05)');</span>
0103 <span class="comment">%</span>
0104 <span class="comment">%   % Refine a function until the areas of the triangles formed by</span>
0105 <span class="comment">%   % triplets of successive points are smaller than 'maxArea'.</span>
0106 <span class="comment">%   y = adaptive(f, x, 'maxArea',1e-3);</span>
0107 <span class="comment">%   figure(4); plot(x,f(x),'s-',x2,f(x2),'k--',y(:,1),y(:,2),'o-');</span>
0108 <span class="comment">%   legend('initial sampling','high sampling','adaptive')</span>
0109 <span class="comment">%   title('y = adaptive(f, x, ''maxArea'',1e-3)')</span>
0110 <span class="comment">%</span>
0111 <span class="comment">%   % Refine a function until the segments formed by pairs of successive</span>
0112 <span class="comment">%   % points are shorter than 'maxLength'.</span>
0113 <span class="comment">%   y = adaptive(f, x, 'maxLength',0.1);</span>
0114 <span class="comment">%   figure(5); plot(x,f(x),'s-',x2,f(x2),'k--',y(:,1),y(:,2),'o-');</span>
0115 <span class="comment">%   legend('initial sampling','high sampling','adaptive')</span>
0116 <span class="comment">%   title('y = adaptive(f, x, ''maxLength'',0.1)');</span>
0117 
0118 
0119 <span class="comment">%% Copyright</span>
0120 <span class="comment">% 2017, Alberto Comin -  LMU Muenchen</span>
0121 
0122 <span class="comment">% Version changes:</span>
0123 <span class="comment">%</span>
0124 <span class="comment">% 24/01/2017: 1) new default: when no optional argument is given, use the</span>
0125 <span class="comment">%  'angle' method as default 2) it is now possible to provide just the</span>
0126 <span class="comment">%  start and the end of the function domain, instead of having to</span>
0127 <span class="comment">%  explicitly provide an initial array 3) a new key-word argument</span>
0128 <span class="comment">%  'nPoints' controls the number of initial domain points in the cases when</span>
0129 <span class="comment">%  the initial array is not explicitly provided. 4) it is now possible to</span>
0130 <span class="comment">%  return the domain points and the function values either as a single 2D</span>
0131 <span class="comment">%  array or as two separate arrays.</span>
0132 <span class="comment">% 25/01/2017: fixed defaults for the case when no method is specified</span>
0133 
0134 <span class="comment">%% Default settings</span>
0135 
0136 out = cell(2,1);
0137 vectorizable = false;
0138 thresholdingSignal = false;
0139 thresholdingLength = false;
0140 thresholdingArea = false;
0141 thresholdingAngles = false;
0142 displayWaitbar = false;
0143 maxRefinements = 10;
0144 <span class="comment">%nPoints = 20;</span>
0145 <span class="comment">%minAngle = 0.8*pi;</span>
0146 minSignal = 0.2; <span class="comment">% units normalized to data range</span>
0147 minLength = 0; <span class="comment">% units normalized to data range</span>
0148 maxLength = Inf; <span class="comment">% units normalized to data range</span>
0149 maxArea = 5e-4; <span class="comment">% units normalized to data range</span>
0150 
0151 <span class="comment">%% Test-mode</span>
0152 <span class="comment">% The test mode is activated by calling 'adaptive.m' with no input.</span>
0153 
0154 <span class="comment">% if nargin==0</span>
0155 <span class="comment">%   initialDomain =  -10:10;</span>
0156 <span class="comment">%   input_func = @(x) 100*exp(-(x+5.2).^2) + 50*exp(-5*(x-0.5).^2)+ 20*exp(-10*(x-5.8).^2);</span>
0157 <span class="comment">%   thresholdingAngles = true;</span>
0158 <span class="comment">%   minAngle = 0.8*pi;</span>
0159 <span class="comment">%   thresholdingLength = true;</span>
0160 <span class="comment">%   minLength = 0.02;</span>
0161 <span class="comment">%   disp('Running adaptive.m in test mode');</span>
0162 <span class="comment">%   fprintf('input function: %s\n',func2str(input_func));</span>
0163 <span class="comment">%   disp('Plotting the function on a initial set of points');</span>
0164 <span class="comment">%   testFigureHandle = figure();</span>
0165 <span class="comment">%   plot(initialDomain, input_func(initialDomain),'bs-','LineWidth',1.5);</span>
0166 <span class="comment">%   grid on; xlabel('x'); ylabel('y'); title('adaptive.m example');</span>
0167 <span class="comment">% end</span>
0168 
0169 
0170 <span class="comment">%% Processing input arguments</span>
0171 <span class="comment">% assert(isa(input_func,'function_handle'),'adaptiveFunctionEvaluation:ArgChk',...</span>
0172 <span class="comment">%   'the first argument must be a function handle');</span>
0173 <span class="comment">% assert(isnumeric(initialDomain) &amp;&amp; isvector(initialDomain),...</span>
0174 <span class="comment">%   'adaptiveFunctionEvaluation:ArgChk','initial points must be specified as a numeric vector');</span>
0175 <span class="comment">%</span>
0176 <span class="comment">%nExtraArgIn = numel(varargin);</span>
0177 <span class="comment">% if mod(nExtraArgIn,2)==1</span>
0178 <span class="comment">%   error('adaptiveFunctionEvaluation:ArgChk', ...</span>
0179 <span class="comment">%     'At least a key or a value is missing in the key-value arguments list.');</span>
0180 <span class="comment">% end</span>
0181 
0182 <span class="comment">%usingDefaultMethod = true;</span>
0183 <span class="comment">%n = 1;</span>
0184 <span class="comment">%minAngle = 0.7 * pi;</span>
0185 <span class="comment">%thresholdingAngles = true;</span>
0186 <span class="comment">%nPoints = 50;</span>
0187       
0188 <span class="comment">% while n &lt; nExtraArgIn</span>
0189 <span class="comment">%   switch lower(varargin{n})</span>
0190 <span class="comment">%     case 'minangle'</span>
0191       <span class="comment">%minAngle = varargin{n+1};</span>
0192       thresholdingAngles = true;
0193       usingDefaultMethod = false;
0194       <span class="comment">%n = n+2;</span>
0195 <span class="comment">%     case 'maxarea'</span>
0196 <span class="comment">%       maxArea = varargin{n+1};</span>
0197 <span class="comment">%       thresholdingArea = true;</span>
0198 <span class="comment">%       usingDefaultMethod = false;</span>
0199 <span class="comment">%       n = n+2;</span>
0200 <span class="comment">%     case 'maxlength'</span>
0201 <span class="comment">%       maxLength = varargin{n+1};</span>
0202 <span class="comment">%       thresholdingLength = true;</span>
0203 <span class="comment">%       usingDefaultMethod = false;</span>
0204 <span class="comment">%       n = n+2;</span>
0205 <span class="comment">%     case 'minlength'</span>
0206 <span class="comment">%       minLength = varargin{n+1};</span>
0207 <span class="comment">%       thresholdingLength = true;</span>
0208 <span class="comment">%       n = n+2;</span>
0209 <span class="comment">%     case 'minsignal'</span>
0210 <span class="comment">%       minSignal = varargin{n+1};</span>
0211 <span class="comment">%       thresholdingSignal = true;</span>
0212 <span class="comment">%       n = n+2;</span>
0213 <span class="comment">%     case 'npoints'</span>
0214 <span class="comment">%       nPoints = varargin{n+1};</span>
0215 <span class="comment">%       n = n+2;</span>
0216 <span class="comment">%     case 'vectorize'</span>
0217 <span class="comment">%       vectorizable = varargin{n+1};</span>
0218 <span class="comment">%       n = n+2;</span>
0219 <span class="comment">%     case 'maxrefinements'</span>
0220 <span class="comment">%       maxRefinements = varargin{n+1};</span>
0221 <span class="comment">%       n = n+2;</span>
0222 <span class="comment">%     case 'waitbar'</span>
0223 <span class="comment">%       displayWaitbar = varargin{n+1};</span>
0224 <span class="comment">%       n = n+2;</span>
0225 <span class="comment">%     otherwise</span>
0226 <span class="comment">%       error('adaptiveFunctionEvaluation:ArgChk',...</span>
0227 <span class="comment">%         ['unknown keyword argument: ', varargin{n}]);</span>
0228 <span class="comment">%   end</span>
0229 <span class="comment">% end</span>
0230 
0231 <span class="comment">% if no method is specified use the 'angle' method as default</span>
0232 <span class="comment">% if usingDefaultMethod</span>
0233 <span class="comment">%   thresholdingAngles = true;</span>
0234 <span class="comment">% end</span>
0235 
0236 <span class="comment">%% Initial function evaluation</span>
0237 
0238 <span class="comment">% if initialDomain only contains the start and the end points, create a new</span>
0239 <span class="comment">% array with 'nPoints' points.</span>
0240 <span class="keyword">if</span> numel(startDomain) == 2
0241   newDomain = linspace(startDomain(1),startDomain(end),nPoints).';
0242   initialDomain =  newDomain;
0243 <span class="keyword">end</span>
0244 <span class="comment">% Normalize the input function: This step allows to use the same syntax for</span>
0245 <span class="comment">% functions with single or multiple output parameters.</span>
0246 
0247 <span class="comment">% Remove this syntax for compile - AVH</span>
0248 
0249 <span class="comment">%func = @(x) normalizeFunction(x,sldProfile,vectorizable);</span>
0250 <span class="comment">% Evaluate the input function on the initial set of points.</span>
0251 
0252 hiVal = <a href="#_sub1" class="code" title="subfunction y = normalizeFunction(x, sldProfile,vectorizable)">normalizeFunction</a>(initialDomain(:),sldProfile,vectorizable);
0253 <span class="comment">%dataPoints = [initialDomain(:), func(initialDomain(:))];</span>
0254 
0255 dataPoints = [initialDomain(:), hiVal];
0256 coder.varsize(<span class="string">'dataPoints'</span>,[Inf Inf],[1 1]);
0257 
0258 <span class="comment">%% Iterative function refinement</span>
0259 <span class="comment">% if displayWaitbar</span>
0260 <span class="comment">%   refinementWaitbar = waitbar(0,['Evaluating function ',func2str(func)],...</span>
0261 <span class="comment">%     'CreateCancelBtn','setappdata(gcbf,''canceling'',true)');</span>
0262 <span class="comment">%   setappdata(refinementWaitbar,'canceling',false)</span>
0263 <span class="comment">% end</span>
0264 
0265 <span class="keyword">for</span> nRefinements = 1:maxRefinements
0266   <span class="comment">% calculate the box which encloses the current data points:</span>
0267   dataBoxSize = max(dataPoints(:,1:2)) - min(dataPoints(:,1:2));
0268   dataBoxArea = prod(dataBoxSize);
0269   
0270   <span class="comment">% Each point is considered as the central corner of the triangle formed</span>
0271   <span class="comment">% with its left and right hand side neighbours. The first and the last</span>
0272   <span class="comment">% points are not the central corner of any triangle, so for N points</span>
0273   <span class="comment">% there are only N-2 triangles.</span>
0274   trianglesToRefine = [false(size(dataPoints,1)-2 ,1)];
0275 <span class="comment">%   if thresholdingArea</span>
0276 <span class="comment">%     triangleArea = calculateTrianglesArea(dataPoints(:,1:2));</span>
0277 <span class="comment">%     bigTriangles = triangleArea &gt; (maxArea * dataBoxArea);</span>
0278 <span class="comment">%     trianglesToRefine = trianglesToRefine | bigTriangles;</span>
0279 <span class="comment">%   end</span>
0280   <span class="keyword">if</span> thresholdingAngles
0281     cornerAngle = <a href="#_sub3" class="code" title="subfunction cornerAngle = calculateCentralAngles(XYdata, dataBoxSize)">calculateCentralAngles</a>(dataPoints(:,1:2), dataBoxSize);
0282     sharpCorners = (cornerAngle&lt;minAngle);
0283     trianglesToRefine = trianglesToRefine | sharpCorners;
0284   <span class="keyword">end</span>
0285   
0286   <span class="comment">% For N points there are N-2 triangles and N-1 triangle sides. Each</span>
0287   <span class="comment">% triangle side is a segment, which can be split or not depending on the</span>
0288   <span class="comment">% refinement parameters.</span>
0289   segmentsToSplit = [trianglesToRefine; false] | [false; trianglesToRefine];
0290 <span class="comment">%   if thresholdingLength</span>
0291 <span class="comment">%     dataSegments = diff(dataPoints(:,1:2));</span>
0292 <span class="comment">%     normalizedSegments = bsxfun(@rdivide, dataSegments, dataBoxSize);</span>
0293 <span class="comment">%     segmentsLengthNormalized = hypot(normalizedSegments(:,1), normalizedSegments(:,2));</span>
0294 <span class="comment">%     tooLongSegments = segmentsLengthNormalized &gt; maxLength;</span>
0295 <span class="comment">%     longEnoughSegments = segmentsLengthNormalized &gt; minLength;</span>
0296 <span class="comment">%     segmentsToSplit = (segmentsToSplit | tooLongSegments) &amp; longEnoughSegments;</span>
0297 <span class="comment">%   end</span>
0298 <span class="comment">%   if thresholdingSignal</span>
0299 <span class="comment">%     segmentsCenters = (dataPoints(1:end-1,2)+dataPoints(2:end,2))/2;</span>
0300 <span class="comment">%     centerAboveThreshold = segmentsCenters &gt; minSignal * max(abs(dataPoints(:,2)));</span>
0301 <span class="comment">%     segmentsToSplit = segmentsToSplit &amp; centerAboveThreshold;</span>
0302 <span class="comment">%   end</span>
0303   
0304   <span class="keyword">if</span> any(segmentsToSplit)
0305     dataPoints = <a href="#_sub5" class="code" title="subfunction dataPoints = increaseSampling(dataPoints, segmentsToSplit, sldProfile)">increaseSampling</a>(dataPoints, segmentsToSplit, sldProfile);
0306   <span class="keyword">else</span>
0307     <span class="keyword">break</span>;
0308   <span class="keyword">end</span>
0309   
0310   <span class="comment">% Removed waitbar for compile - AVH</span>
0311   
0312 <span class="comment">%   if displayWaitbar</span>
0313 <span class="comment">%     if getappdata(refinementWaitbar,'canceling'), break; end</span>
0314 <span class="comment">%     waitbar(nRefinements/maxRefinements,refinementWaitbar);</span>
0315 <span class="comment">%   end</span>
0316 <span class="keyword">end</span>
0317 
0318 <span class="comment">% if displayWaitbar</span>
0319 <span class="comment">%   delete(refinementWaitbar);</span>
0320 <span class="comment">% end</span>
0321 
0322 <span class="comment">%% Plotting refined function</span>
0323 
0324 <span class="comment">% Removed for compile - AVH</span>
0325 
0326 <span class="comment">% if nargin==0 % test mode</span>
0327 <span class="comment">%   figure(testFigureHandle);</span>
0328 <span class="comment">%   hold on;</span>
0329 <span class="comment">%   plot(dataPoints(:,1), dataPoints(:,2),'ro-');</span>
0330 <span class="comment">%   legend('initial', 'refiniment');</span>
0331 <span class="comment">% end</span>
0332 
0333 <span class="comment">%if nargout==1</span>
0334  out{1} = dataPoints;
0335 <span class="comment">% elseif nargout&gt;1</span>
0336 <span class="comment">%   out{1} = dataPoints(:,1);</span>
0337 <span class="comment">%   out{2} = dataPoints(:,2:end);</span>
0338 <span class="comment">% end</span>
0339 <span class="keyword">end</span>
0340 
0341 <span class="comment">%% Subfunctions</span>
0342 
0343 <a name="_sub1" href="#_subfunctions" class="code">function y = normalizeFunction(x, sldProfile,vectorizable)</a>
0344 <span class="comment">% NORMALIZEFUNCTION evaluates a function and returns a NxM array, where N</span>
0345 <span class="comment">% is the number of elements of x and M is the number of outputs of func.</span>
0346 <span class="comment">% All the outputs of func must be scalar.</span>
0347 <span class="comment">% The optional parameter 'vectorizable' (default false) allows to specify</span>
0348 <span class="comment">% that the input function can be vectorized.</span>
0349 
0350 
0351 <span class="comment">% Modified by AVH for use with coder</span>
0352 
0353 
0354 
0355 <span class="comment">%if (~exist('vectorizable','var') || isempty(vectorizable))</span>
0356   vectorizable=false;
0357 <span class="comment">% end</span>
0358 no_elements = numel(x);
0359 no_outputs = 1; <span class="comment">%abs(nargout(func)); %for anonymous functions nargout&lt;0</span>
0360 y = zeros(no_elements, no_outputs);
0361 newValues = cell(1, no_outputs);
0362 <span class="comment">% if vectorizable</span>
0363 <span class="comment">%   % For uniformity reasons, transform the 'x' array into a column vector.</span>
0364 <span class="comment">%   % In this way it does not matter if it is given as a column or a row</span>
0365 <span class="comment">%   % vector.</span>
0366 <span class="comment">%   [newValues{:}] = func(x(:));</span>
0367 <span class="comment">%   y = cell2mat(newValues);</span>
0368 <span class="comment">% else</span>
0369   <span class="keyword">for</span> i=1:no_elements
0370       <span class="comment">% Remove cell array so no need for cell2mat</span>
0371       <span class="comment">% which won't compile - AVH</span>
0372       
0373     <span class="comment">%[newValues{:}] = func(x(i));</span>
0374     <span class="comment">%y(i,:) = cell2mat(newValues);</span>
0375     
0376     y(i) = <a href="SLDFunction.html" class="code" title="function sldVal = SLDFunction(x,SLD)">SLDFunction</a>(x(i),sldProfile);
0377   <span class="keyword">end</span>
0378 <span class="comment">%end</span>
0379 <span class="keyword">end</span>
0380 
0381 <a name="_sub2" href="#_subfunctions" class="code">function [firstStep,secondStep,longStep] = calculateTrianglesSides(XYdata)</a>
0382 <span class="comment">% Return the sides (deltaX, deltaY) of the triangles formed by data points.</span>
0383 <span class="comment">% For input size NxM, the output size is (N-2)xN, because the first and the</span>
0384 <span class="comment">% last point are not the central corner of any triangle.</span>
0385 
0386 firstStep = XYdata(2:end-1,:) - XYdata(1:end-2,:);
0387 secondStep = XYdata(3:<span class="keyword">end</span>  ,:) - XYdata(2:end-1,:);
0388 longStep  = XYdata(3:<span class="keyword">end</span>  ,:) - XYdata(1:end-2,:);
0389 <span class="keyword">end</span>
0390 
0391 <a name="_sub3" href="#_subfunctions" class="code">function cornerAngle = calculateCentralAngles(XYdata, dataBoxSize)</a>
0392 <span class="comment">% Calculate the central angle of the triangles formed by data points.</span>
0393 <span class="comment">% For input size NxM, the output size is (N-2)xN, because the first and the</span>
0394 <span class="comment">% last point are not the central corner of any triangle.</span>
0395 
0396 <span class="comment">% Normalize data, because angles depend on scaling.</span>
0397 normalizedData = <span class="keyword">...</span>
0398   XYdata ./ repmat(dataBoxSize, size(XYdata,1), 1) - <span class="keyword">...</span>
0399   repmat(min(XYdata), size(XYdata,1), 1);
0400 <span class="comment">% calculate cosine of central angles</span>
0401 [firstStep,secondStep,longStep] = <a href="#_sub2" class="code" title="subfunction [firstStep,secondStep,longStep] = calculateTrianglesSides(XYdata)">calculateTrianglesSides</a>(normalizedData);
0402 <span class="comment">% calculate area of squares of length of triangle sides</span>
0403 firstStepSquared  = firstStep(:,1).^2  + firstStep(:,2).^2;
0404 secondStepSquared = secondStep(:,1).^2 + secondStep(:,2).^2;
0405 longStepSquared   = longStep(:,1).^2   + longStep(:,2).^2;
0406 cosCornerAngle = <span class="keyword">...</span>
0407   (firstStepSquared + secondStepSquared - longStepSquared) / 2 ./ <span class="keyword">...</span>
0408   sqrt(firstStepSquared .* secondStepSquared);
0409 cornerAngle = real(acos(complex(cosCornerAngle)));
0410 <span class="keyword">end</span>
0411 
0412 <a name="_sub4" href="#_subfunctions" class="code">function triangleArea = calculateTrianglesArea(XYdata)</a>
0413 <span class="comment">% CalculateTrianglesArea of triangles formed by data points using shoelace</span>
0414 <span class="comment">% formula.</span>
0415 <span class="comment">% For input size NxM, the output size is (N-2)xN, because the first and the</span>
0416 <span class="comment">% last point are not the central corner of any triangle.</span>
0417 
0418 [firstStep, ~, longStep] = <a href="#_sub2" class="code" title="subfunction [firstStep,secondStep,longStep] = calculateTrianglesSides(XYdata)">calculateTrianglesSides</a>(XYdata);
0419 triangleArea = 0.5 * abs(-longStep(:,1).*firstStep(:,2) + firstStep(:,1).*longStep(:,2));
0420 <span class="keyword">end</span>
0421 
0422 <a name="_sub5" href="#_subfunctions" class="code">function dataPoints = increaseSampling(dataPoints, segmentsToSplit, sldProfile)</a>
0423 <span class="comment">% increaseSampling increase the sampling of an input function</span>
0424 
0425 noPointsToAdd = numel(segmentsToSplit(segmentsToSplit==true));
0426 newDataPoints = zeros(noPointsToAdd, size(dataPoints,2));
0427 coder.varsize(<span class="string">'newDataPoints'</span>,[Inf Inf],[1 1]);
0428 
0429 newDataPoints(:,1) = 0.5 * (dataPoints([segmentsToSplit;false],1) + <span class="keyword">...</span>
0430   dataPoints([false;segmentsToSplit],1));
0431 newDataPoints(:,2) = <a href="#_sub1" class="code" title="subfunction y = normalizeFunction(x, sldProfile,vectorizable)">normalizeFunction</a>(newDataPoints(:,1),sldProfile);
0432 <span class="comment">% For simplicity append the new points at the end and then sort.</span>
0433 dataPoints = sortrows( [ dataPoints; newDataPoints ]);
0434 <span class="keyword">end</span>
</pre></div>

<hr><address>Generated on Fri 10-Mar-2023 11:17:15 by <strong><a href="https://github.com/gllmflndn/m2html">m2html</a></strong> &copy; 2003-2022</address>
</body>
</html>

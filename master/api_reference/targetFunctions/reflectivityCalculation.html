<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of reflectivityCalculation</title>
  <meta name="keywords" content="reflectivityCalculation">
  <meta name="description" content="Main entry point into the reflectivity calculation for the toolbox.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003-2019 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- menu.html targetFunctions -->

<h1>reflectivityCalculation
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>Main entry point into the reflectivity calculation for the toolbox.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function result = reflectivityCalculation(problemStruct,problemCells,problemLimits,controls) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Main entry point into the reflectivity calculation for the toolbox.
 This is the main function that is called by any of the minimisers or
 analysis tools from the rest of the toolbox. 

 *The main job of this function is to decide which type of calculation
 (i.e. 'Target function' is required, and call the relevant routines.
 The types of available target functions are:*

 * non polarised  - The main basic target function type, for non polarised neutrons (or x-rays) with non-absorbing samples. Different model types are specified in sub functions from here.

 * oil water      - Target function for oil-water samples

 * domains        - Target function for samples consisting of domains which are larger than the beam lateral coherence length.

 * magnetic       - Target function for cases for polarised neutrons with polarisation analysis.
                       
</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="../API/RATMain.html" class="code" title="function [problemStruct,result,bayesResults] = RATMain(problemStruct,problemCells,problemLimits,controls,priors)">RATMain</a>	</li>
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function result = reflectivityCalculation(problemStruct,problemCells,problemLimits,controls)</a>
0002 <span class="comment">% Main entry point into the reflectivity calculation for the toolbox.</span>
0003 <span class="comment">% This is the main function that is called by any of the minimisers or</span>
0004 <span class="comment">% analysis tools from the rest of the toolbox.</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% *The main job of this function is to decide which type of calculation</span>
0007 <span class="comment">% (i.e. 'Target function' is required, and call the relevant routines.</span>
0008 <span class="comment">% The types of available target functions are:*</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% * non polarised  - The main basic target function type, for non polarised neutrons (or x-rays) with non-absorbing samples. Different model types are specified in sub functions from here.</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% * oil water      - Target function for oil-water samples</span>
0013 <span class="comment">%</span>
0014 <span class="comment">% * domains        - Target function for samples consisting of domains which are larger than the beam lateral coherence length.</span>
0015 <span class="comment">%</span>
0016 <span class="comment">% * magnetic       - Target function for cases for polarised neutrons with polarisation analysis.</span>
0017 <span class="comment">%</span>
0018 
0019 <span class="comment">% For compilation, we have to preallocate memory for the output structs</span>
0020 numberOfContrasts = problemStruct.numberOfContrasts;
0021 preAlloc = zeros(numberOfContrasts,1);
0022 
0023 contrastParams = struct(<span class="string">'backgroundParams'</span>,preAlloc,<span class="keyword">...</span>
0024                         <span class="string">'scalefactors'</span>,preAlloc,<span class="keyword">...</span>
0025                         <span class="string">'bulkIn'</span>,preAlloc,<span class="keyword">...</span>
0026                         <span class="string">'bulkOut'</span>,preAlloc,<span class="keyword">...</span>
0027                         <span class="string">'resolutionParams'</span>,preAlloc,<span class="keyword">...</span>
0028                         <span class="string">'subRoughs'</span>,preAlloc,<span class="keyword">...</span>
0029                         <span class="string">'resample'</span>,preAlloc);
0030 
0031 calculationResults = struct(<span class="string">'chiValues'</span>,preAlloc,<span class="string">'sumChi'</span>,0);
0032 
0033 <span class="comment">% We also fill the results arrays to define their type and size.</span>
0034 reflectivity = cell(numberOfContrasts,1);
0035 <span class="keyword">for</span> i = 1:numberOfContrasts
0036     reflectivity{i} = [1 1; 1 1];
0037 <span class="keyword">end</span>
0038 coder.varsize(<span class="string">'reflectivity{:}'</span>,[10000 2],[1 0]);
0039 
0040 simulation = cell(numberOfContrasts,1);
0041 <span class="keyword">for</span> i = 1:numberOfContrasts
0042     simulation{i} = [1 1; 1 1];
0043 <span class="keyword">end</span>
0044 coder.varsize(<span class="string">'simulation{:}'</span>,[10000 2],[1 0]);
0045 
0046 shiftedData = cell(numberOfContrasts,1);
0047 <span class="keyword">for</span> i = 1:numberOfContrasts
0048     shiftedData{i} = [1 1 1; 1 1 1];
0049 <span class="keyword">end</span>
0050 coder.varsize(<span class="string">'shiftedData{:}'</span>,[10000 3],[1 0]);
0051 
0052 layerSlds = cell(numberOfContrasts,1);
0053 <span class="keyword">for</span> i = 1:numberOfContrasts
0054     layerSlds{i} = [1 1 1; 1 1 1];
0055 <span class="keyword">end</span>
0056 coder.varsize(<span class="string">'layerSlds{:}'</span>,[10000 6],[1 1]);
0057 
0058 domainLayerSlds = cell(numberOfContrasts,2);
0059 <span class="keyword">for</span> i = 1:numberOfContrasts
0060     domainLayerSlds{i,1} = [1 1 1; 1 1 1];
0061     domainLayerSlds{i,2} = [1 1 1; 1 1 1];
0062 <span class="keyword">end</span>
0063 coder.varsize(<span class="string">'domainLayerSlds'</span>,[10000 2],[1 1]);
0064 coder.varsize(<span class="string">'domainLayerSlds{:}'</span>,[10000 6],[1 1]);
0065 
0066 sldProfiles = cell(numberOfContrasts,1);
0067 <span class="keyword">for</span> i = 1:numberOfContrasts
0068     sldProfiles{i,1} = [1 1; 1 1];
0069 <span class="keyword">end</span>
0070 coder.varsize(<span class="string">'sldProfiles{:}'</span>,[10000 2],[1 0]);
0071 
0072 domainSldProfiles = cell(numberOfContrasts,2);
0073 <span class="keyword">for</span> i = 1:numberOfContrasts
0074     domainSldProfiles{i,1} = [1 1; 1 1];
0075     domainSldProfiles{i,2} = [1 1; 1 1];
0076 <span class="keyword">end</span>
0077 coder.varsize(<span class="string">'domainSldProfiles'</span>,[10000 2],[1 1]);
0078 coder.varsize(<span class="string">'domainSldProfiles{:}'</span>,[10000 Inf],[1 1]);
0079 
0080 resampledLayers = cell(numberOfContrasts,1);
0081 <span class="keyword">for</span> i = 1:numberOfContrasts
0082     resampledLayers{i} = [1 1 1; 1 1 1];
0083 <span class="keyword">end</span>
0084 coder.varsize(<span class="string">'resampledLayers{:}'</span>,[10000 3],[1 0]);
0085 
0086 domainResampledLayers = cell(numberOfContrasts,2);
0087 <span class="keyword">for</span> i = 1:numberOfContrasts
0088     domainResampledLayers{i,1} = [1 1 1; 1 1 1];
0089     domainResampledLayers{i,2} = [1 1 1; 1 1 1];
0090 <span class="keyword">end</span>
0091 coder.varsize(<span class="string">'domainResampledLayers'</span>,[10000 2],[1 1]);
0092 coder.varsize(<span class="string">'domainResampledLayers{:}'</span>,[10000 3],[1 0]);
0093 
0094 <span class="comment">% Decide which target function we are calling and call the relevant routines</span>
0095 whichTF = problemStruct.TF;
0096 <span class="keyword">switch</span> whichTF
0097     <span class="keyword">case</span> coderEnums.calculationTypes.NonPolarised
0098         [contrastParams,calculationResults,reflectivity,simulation,shiftedData,layerSlds,sldProfiles,resampledLayers] = nonPolarisedTF.reflectivityCalculation(problemStruct,problemCells,controls);
0099     <span class="comment">%case coderEnums.calculationTypes.OilWater</span>
0100         <span class="comment">%contrastParams = oilWaterTFReflectivityCalculation(problemStruct,problemCells,controls);</span>
0101     <span class="comment">%case coderEnums.calculationTypes.Magnetic</span>
0102         <span class="comment">%contrastParams = polarisedTFReflectivityCalculation(problemStruct,problemCells,controls);</span>
0103     <span class="keyword">case</span> coderEnums.calculationTypes.Domains
0104         [contrastParams,calculationResults,reflectivity,simulation,shiftedData,domainLayerSlds,domainSldProfiles,domainResampledLayers] = domainsTF.reflectivityCalculation(problemStruct,problemCells,controls);
0105     <span class="keyword">otherwise</span>
0106         error(<span class="string">'The calculation type &quot;%s&quot; is not supported'</span>, whichTF);
0107 
0108 <span class="keyword">end</span>
0109 
0110 <span class="comment">% Make the result struct</span>
0111 result.reflectivity = reflectivity;
0112 result.simulation = simulation;
0113 result.shiftedData = shiftedData;
0114 
0115 <span class="comment">% The size of this array now varies depending on TF</span>
0116 <span class="keyword">switch</span> whichTF
0117     <span class="keyword">case</span> coderEnums.calculationTypes.Domains
0118 
0119         result.layerSlds = domainLayerSlds;
0120         result.sldProfiles = domainSldProfiles;
0121         result.resampledLayers = domainResampledLayers;
0122 
0123     <span class="keyword">otherwise</span>
0124 
0125         result.layerSlds = layerSlds;
0126         result.sldProfiles = sldProfiles;
0127         result.resampledLayers = resampledLayers;
0128 
0129 <span class="keyword">end</span>
0130 
0131 <span class="comment">% Complete the result struct</span>
0132 [~,fitNames] = packParams(problemStruct,problemCells,problemLimits,controls.checks);
0133 
0134 result.calculationResults = calculationResults;
0135 result.contrastParams = contrastParams;
0136 result.fitParams = problemStruct.fitParams;
0137 result.fitNames = fitNames;
0138 
0139 <span class="keyword">end</span>
</pre></div>

<hr><address>Generated on Wed 05-Jun-2024 09:06:47 by <strong><a href="https://github.com/gllmflndn/m2html">m2html</a></strong> &copy; 2003-2022</address>
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of reflectivityCalculation</title>
  <meta name="keywords" content="reflectivityCalculation">
  <meta name="description" content="Main entry point into the reflectivity calculation for the toolbox.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003-2019 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- menu.html targetFunctions -->

<h1>reflectivityCalculation
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>Main entry point into the reflectivity calculation for the toolbox.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [problem,result] = reflectivityCalculation(problemDef,problemDefCells,controls) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Main entry point into the reflectivity calculation for the toolbox.
 This is the main function that is called by any of the minimisers or
 analysis tools from the rest of the toolbox. 

 *The main job of this function is to decide which type of calculation
 (i.e. 'Target function' is required, and call the relevant routines.
 The types of available target functions are:*

 * non polarised  - The main basic target function type, for non polarised neutrons (or x-rays) with non-absorbing samples. Different model types are specified in sub functions from here.

 * oil water      - Target function for oil-water samples

 * domains        - Target function for samples consisting of domains which are larger than the beam lateral coherence length.

 * magnetic       - Target function for cases for polarised neutrons with polarisation analysis.
                       
</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="../API/RATMain.html" class="code" title="function [outProblemDef,problem,results,bayesResults] = RATMain(problemDef,problemDefCells,problemDefLimits,controls,priors)">RATMain</a>	</li>
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [problem,result] = reflectivityCalculation(problemDef,problemDefCells,controls)</a>
0002 <span class="comment">% Main entry point into the reflectivity calculation for the toolbox.</span>
0003 <span class="comment">% This is the main function that is called by any of the minimisers or</span>
0004 <span class="comment">% analysis tools from the rest of the toolbox.</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% *The main job of this function is to decide which type of calculation</span>
0007 <span class="comment">% (i.e. 'Target function' is required, and call the relevant routines.</span>
0008 <span class="comment">% The types of available target functions are:*</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% * non polarised  - The main basic target function type, for non polarised neutrons (or x-rays) with non-absorbing samples. Different model types are specified in sub functions from here.</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% * oil water      - Target function for oil-water samples</span>
0013 <span class="comment">%</span>
0014 <span class="comment">% * domains        - Target function for samples consisting of domains which are larger than the beam lateral coherence length.</span>
0015 <span class="comment">%</span>
0016 <span class="comment">% * magnetic       - Target function for cases for polarised neutrons with polarisation analysis.</span>
0017 <span class="comment">%</span>
0018 
0019 <span class="comment">% triggerEvent('message', 'Running reflectivity calculation...');</span>
0020 
0021 <span class="comment">% for compilation, we have to preallocate memory for the output arrays</span>
0022 <span class="comment">% Setting these parameters in the struct defines them as doubles</span>
0023 problem.ssubs = 0;
0024 problem.backgroundParams = 0;
0025 problem.qzshifts = 0;
0026 problem.scalefactors = 0;
0027 problem.bulkIn = 0;
0028 problem.bulkOut = 0;
0029 problem.resolutionParams = 0;
0030 problem.calculations.all_chis = 0;
0031 problem.calculations.sum_chi = 0;
0032 problem.allSubRough = 0;
0033 problem.resample = 0;
0034 
0035 <span class="comment">% We also foll the results arrays to define their</span>
0036 <span class="comment">% type and size. (NOTE: at the moment we have a 'coder.varsize'</span>
0037 <span class="comment">% pre-processor directives for the compiler here and at the</span>
0038 <span class="comment">% end for the results block. We are unlikely to need both</span>
0039 <span class="comment">% TODO: Find out which is necessary and tidy this up.</span>
0040 
0041 numberOfContrasts = problemDef.numberOfContrasts;
0042 reflectivity = cell(numberOfContrasts,1);
0043 <span class="keyword">for</span> i = 1:numberOfContrasts
0044     reflectivity{i} = [1 1 ; 1 1];
0045 <span class="keyword">end</span>
0046 coder.varsize(<span class="string">'reflectivity{:}'</span>,[10000 2],[1 0]);
0047 
0048 Simulation = cell(numberOfContrasts,1);
0049 <span class="keyword">for</span> i = 1:numberOfContrasts
0050     Simulation{i} = [1 1 ; 1 1];
0051 <span class="keyword">end</span>
0052 coder.varsize(<span class="string">'Simulation{:}'</span>,[10000 2],[1 0]);
0053 
0054 shifted_data = cell(numberOfContrasts,1);
0055 <span class="keyword">for</span> i = 1:numberOfContrasts
0056     shifted_data{i} = [1 1 1 ; 1 1 1];
0057 <span class="keyword">end</span>
0058 coder.varsize(<span class="string">'shifted_data{:}'</span>,[10000 3],[1 0]);
0059 
0060 layerSlds = cell(numberOfContrasts,1);
0061 <span class="keyword">for</span> i = 1:numberOfContrasts
0062     layerSlds{i} = [1 1 1 ; 1 1 1];
0063 <span class="keyword">end</span>
0064 coder.varsize(<span class="string">'layerSlds{:}'</span>,[10000 6],[1 1]);
0065 
0066 domainLayerSlds = cell(numberOfContrasts,2);
0067 <span class="keyword">for</span> i = 1:numberOfContrasts
0068     domainLayerSlds{i,1} = [1 1 1 ; 1 1 1];
0069     domainLayerSlds{i,2} = [1 1 1 ; 1 1 1];
0070 <span class="keyword">end</span>
0071 coder.varsize(<span class="string">'domainLayerSlds'</span>,[10000 2],[1 1]);
0072 coder.varsize(<span class="string">'domainLayerSlds{:}'</span>,[10000 6],[1 1]);
0073 
0074 sldProfiles = cell(numberOfContrasts,1);
0075 <span class="keyword">for</span> i = 1:numberOfContrasts
0076     sldProfiles{i,1} = [1 1 ; 1 1];
0077 <span class="keyword">end</span>
0078 coder.varsize(<span class="string">'sldProfiles{:}'</span>,[10000 2],[1 0]);
0079 
0080 domainSldProfiles = cell(numberOfContrasts,2);
0081 <span class="keyword">for</span> i = 1:numberOfContrasts
0082     domainSldProfiles{i,1} = [1 1 ; 1 1];
0083     domainSldProfiles{i,2} = [1 1 ; 1 1];
0084 <span class="keyword">end</span>
0085 coder.varsize(<span class="string">'domainSldProfiles'</span>,[10000 2],[1 1]);
0086 coder.varsize(<span class="string">'domainSldProfiles{:}'</span>,[10000 Inf],[1 1]);
0087 
0088 allLayers = cell(numberOfContrasts,1);
0089 <span class="keyword">for</span> i = 1:numberOfContrasts
0090     allLayers{i} = [1 1 1; 1 1 1];
0091 <span class="keyword">end</span>
0092 coder.varsize(<span class="string">'allLayers{:}'</span>,[10000 3],[1 0]);
0093 
0094 domainAllLayers = cell(numberOfContrasts,2);
0095 <span class="keyword">for</span> i = 1:numberOfContrasts
0096     domainAllLayers{i,1} = [1 1 1; 1 1 1];
0097     domainAllLayers{i,2} = [1 1 1; 1 1 1];
0098 <span class="keyword">end</span>
0099 coder.varsize(<span class="string">'domainAllLayers'</span>,[10000 2],[1 1]);
0100 coder.varsize(<span class="string">'domainAllLayers{:}'</span>,[10000 3],[1 0]);
0101 
0102 <span class="comment">% Decide which target function we are calling and call the relevant routines</span>
0103 whichTF = problemDef.TF;
0104 <span class="keyword">switch</span> whichTF
0105     <span class="keyword">case</span> <span class="string">'non polarised'</span>
0106         [problem,reflectivity,Simulation,shifted_data,layerSlds,sldProfiles,allLayers] = nonPolarisedTF.reflectivityCalculation(problemDef,problemDefCells,controls);
0107     <span class="comment">%case 'oil water'</span>
0108         <span class="comment">%problem = oilWaterTF_reflectivityCalculation(problemDef,problemDefCells,controls);</span>
0109     <span class="comment">%case 'magnetic'</span>
0110         <span class="comment">%problem = polarisedTF_reflectivityCalculation(problemDef,problemDefCells,controls);</span>
0111     <span class="keyword">case</span> <span class="string">'domains'</span>
0112         [problem,reflectivity,Simulation,shifted_data,domainLayerSlds,domainSldProfiles,domainAllLayers] = domainsTF.reflectivityCalculation(problemDef,problemDefCells,controls);
0113 <span class="comment">%     otherwise</span>
0114 <span class="comment">%         error('The calculation type &quot;%s&quot; is not supported', whichTF);</span>
0115 
0116 <span class="keyword">end</span>
0117 
0118 result = cell(1,6);
0119 
0120 cell1 = cell(numberOfContrasts,1);
0121 <span class="keyword">for</span> i = 1:numberOfContrasts
0122     cell1{i} = reflectivity{i};
0123 <span class="keyword">end</span>
0124 result{1} = cell1;
0125 
0126 cell2 = cell(numberOfContrasts,1);
0127 <span class="keyword">for</span> i = 1:numberOfContrasts
0128     cell2{i} = Simulation{i};
0129 <span class="keyword">end</span>
0130 result{2} = cell2;
0131 
0132 cell3 = cell(numberOfContrasts,1);
0133 <span class="keyword">for</span> i = 1:numberOfContrasts
0134     cell3{i} = shifted_data{i}; 
0135 <span class="keyword">end</span>
0136 result{3} = cell3;
0137 
0138 
0139 <span class="comment">% The size of this array now varies depending on TF</span>
0140 <span class="keyword">switch</span> whichTF
0141     <span class="keyword">case</span> <span class="string">'domains'</span>
0142 
0143         cell4 = cell(numberOfContrasts,2);
0144         <span class="keyword">for</span> i = 1:numberOfContrasts
0145             cell4{i,1} = domainLayerSlds{i,1};
0146             cell4{i,2} = domainLayerSlds{i,2};
0147         <span class="keyword">end</span>
0148         result{4} = cell4;
0149 
0150         cell5 = cell(numberOfContrasts,2);
0151         <span class="keyword">for</span> i = 1:numberOfContrasts
0152             cell5{i,1} = domainSldProfiles{i,1};
0153             cell5{i,2} = domainSldProfiles{i,2};
0154         <span class="keyword">end</span>
0155         result{5} = cell5;
0156 
0157         cell6 = cell(numberOfContrasts,2);
0158         <span class="keyword">for</span> i = 1:numberOfContrasts
0159             cell6{i,1} = domainAllLayers{i,1}; 
0160             cell6{i,2} = domainAllLayers{i,2};
0161         <span class="keyword">end</span>
0162         result{6} = cell6;
0163 
0164     <span class="keyword">otherwise</span>
0165 
0166         cell4 = cell(numberOfContrasts,1);
0167         <span class="keyword">for</span> i = 1:numberOfContrasts
0168             cell4{i} = layerSlds{i};
0169         <span class="keyword">end</span>
0170         result{4} = cell4;
0171 
0172         cell5 = cell(numberOfContrasts,1);
0173         <span class="keyword">for</span> i = 1:numberOfContrasts
0174             cell5{i} = sldProfiles{i};
0175         <span class="keyword">end</span>
0176         result{5} = cell5;
0177 
0178         cell6 = cell(numberOfContrasts,1);
0179         <span class="keyword">for</span> i = 1:numberOfContrasts
0180             cell6{i} = allLayers{i}; 
0181         <span class="keyword">end</span>
0182         result{6} = cell6;
0183 
0184 <span class="keyword">end</span>
0185 
0186 <span class="comment">% Pre-processor directives for Matlab Coder</span>
0187 <span class="comment">% to define the size of the output array</span>
0188 coder.varsize(<span class="string">'problem.ssubs'</span>,[Inf 1],[1 0]);
0189 coder.varsize(<span class="string">'problem.backgroundParams'</span>,[Inf 1],[1 0]);
0190 coder.varsize(<span class="string">'problem.qzshifts'</span>,[Inf 1],[1 0]);
0191 coder.varsize(<span class="string">'problem.scalefactors'</span>,[Inf 1],[1 0]);
0192 coder.varsize(<span class="string">'problem.bulkIn'</span>,[Inf 1],[1 0]);
0193 coder.varsize(<span class="string">'problem.bulkOut'</span>,[Inf 1],[1 0]);
0194 coder.varsize(<span class="string">'problem.resolutionParams'</span>,[Inf 1],[1 0]);
0195 coder.varsize(<span class="string">'problem.ssubs'</span>,[Inf 1],[1 0]);
0196 coder.varsize(<span class="string">'problem.calculations.all_chis'</span>,[Inf 1],[1 0]);
0197 coder.varsize(<span class="string">'problem.calculations.sum_chi'</span>,[1 1],[0 0]);
0198 coder.varsize(<span class="string">'problem.allSubRough'</span>,[Inf 1],[1 0]);
0199 coder.varsize(<span class="string">'problem.resample'</span>,[1 Inf],[0 1]);
0200 
0201 <span class="comment">%Result coder definitions....</span>
0202 coder.varsize(<span class="string">'result{1}'</span>,[Inf 1],[1 0]);           <span class="comment">%Reflectivity</span>
0203 coder.varsize(<span class="string">'result{1}{:}'</span>,[Inf 2],[1 0]);
0204 
0205 coder.varsize(<span class="string">'result{2}'</span>,[Inf 1],[1 0]);           <span class="comment">%Simulation</span>
0206 coder.varsize(<span class="string">'result{2}{:}'</span>,[Inf 2],[1 0]);
0207 
0208 coder.varsize(<span class="string">'result{3}'</span>,[Inf 1],[1 0]);           <span class="comment">%Shifted data</span>
0209 coder.varsize(<span class="string">'result{3}{:}'</span>,[Inf 3],[1 0]);
0210 
0211 <span class="comment">% coder.varsize('result{4}',[Inf 2],[1 1]);           %Layers slds</span>
0212 <span class="comment">% coder.varsize('result{4}{:}',[Inf 6],[1 1]);</span>
0213 
0214 <span class="comment">% coder.varsize('result{5}',[Inf 2],[1 1]);           %Sld profiles</span>
0215 <span class="comment">% coder.varsize('results{5}{:}',[Inf 2],[1 2]);</span>
0216 
0217 <span class="comment">% coder.varsize('result{6}',[Inf 2],[1 1]);           %All layers (resampled)</span>
0218 <span class="comment">% coder.varsize('result{6}{:}',[Inf 3],[1 0]);</span>
0219 <span class="keyword">end</span>
</pre></div>

<hr><address>Generated on Fri 01-Dec-2023 17:22:03 by <strong><a href="https://github.com/gllmflndn/m2html">m2html</a></strong> &copy; 2003-2022</address>
</body>
</html>

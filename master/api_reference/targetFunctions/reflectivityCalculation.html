<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of reflectivityCalculation</title>
  <meta name="keywords" content="reflectivityCalculation">
  <meta name="description" content="Main entry point into the reflectivity calculation for the toolbox.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003-2019 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- menu.html targetFunctions -->

<h1>reflectivityCalculation
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>Main entry point into the reflectivity calculation for the toolbox.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function result = reflectivityCalculation(problemStruct,problemCells,problemLimits,controls) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Main entry point into the reflectivity calculation for the toolbox.
 This is the main function that is called by any of the minimisers or
 analysis tools from the rest of the toolbox. 

 *The main job of this function is to decide which type of calculation
 (i.e. 'Target function' is required, and call the relevant routines.
 The types of available target functions are:*

 * non polarised  - The main basic target function type, for non polarised neutrons (or x-rays) with non-absorbing samples. Different model types are specified in sub functions from here.

 * oil water      - Target function for oil-water samples

 * domains        - Target function for samples consisting of domains which are larger than the beam lateral coherence length.

 * magnetic       - Target function for cases for polarised neutrons with polarisation analysis.
                       
</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="../API/RATMain.html" class="code" title="function [problemStruct,result,bayesResults] = RATMain(problemStruct,problemCells,problemLimits,controls,priors)">RATMain</a>	</li>
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function result = reflectivityCalculation(problemStruct,problemCells,problemLimits,controls)</a>
0002 <span class="comment">% Main entry point into the reflectivity calculation for the toolbox.</span>
0003 <span class="comment">% This is the main function that is called by any of the minimisers or</span>
0004 <span class="comment">% analysis tools from the rest of the toolbox.</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% *The main job of this function is to decide which type of calculation</span>
0007 <span class="comment">% (i.e. 'Target function' is required, and call the relevant routines.</span>
0008 <span class="comment">% The types of available target functions are:*</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% * non polarised  - The main basic target function type, for non polarised neutrons (or x-rays) with non-absorbing samples. Different model types are specified in sub functions from here.</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% * oil water      - Target function for oil-water samples</span>
0013 <span class="comment">%</span>
0014 <span class="comment">% * domains        - Target function for samples consisting of domains which are larger than the beam lateral coherence length.</span>
0015 <span class="comment">%</span>
0016 <span class="comment">% * magnetic       - Target function for cases for polarised neutrons with polarisation analysis.</span>
0017 <span class="comment">%</span>
0018 
0019 <span class="comment">% For compilation, we have to preallocate memory for the output structs</span>
0020 numberOfContrasts = problemStruct.numberOfContrasts;
0021 preAlloc = zeros(numberOfContrasts,1);
0022 
0023 contrastParams = struct(<span class="string">'backgroundParams'</span>,preAlloc,<span class="keyword">...</span>
0024                         <span class="string">'qzshifts'</span>,preAlloc,<span class="keyword">...</span>
0025                         <span class="string">'scalefactors'</span>,preAlloc,<span class="keyword">...</span>
0026                         <span class="string">'bulkIn'</span>,preAlloc,<span class="keyword">...</span>
0027                         <span class="string">'bulkOut'</span>,preAlloc,<span class="keyword">...</span>
0028                         <span class="string">'resolutionParams'</span>,preAlloc,<span class="keyword">...</span>
0029                         <span class="string">'subRoughs'</span>,preAlloc,<span class="keyword">...</span>
0030                         <span class="string">'resample'</span>,preAlloc);
0031 
0032 calculationResults = struct(<span class="string">'chiValues'</span>,preAlloc,<span class="string">'sumChi'</span>,0);
0033 
0034 <span class="comment">% We also fill the results arrays to define their type and size.</span>
0035 reflectivity = cell(numberOfContrasts,1);
0036 <span class="keyword">for</span> i = 1:numberOfContrasts
0037     reflectivity{i} = [1 1; 1 1];
0038 <span class="keyword">end</span>
0039 coder.varsize(<span class="string">'reflectivity{:}'</span>,[10000 2],[1 0]);
0040 
0041 simulation = cell(numberOfContrasts,1);
0042 <span class="keyword">for</span> i = 1:numberOfContrasts
0043     simulation{i} = [1 1; 1 1];
0044 <span class="keyword">end</span>
0045 coder.varsize(<span class="string">'simulation{:}'</span>,[10000 2],[1 0]);
0046 
0047 shiftedData = cell(numberOfContrasts,1);
0048 <span class="keyword">for</span> i = 1:numberOfContrasts
0049     shiftedData{i} = [1 1 1; 1 1 1];
0050 <span class="keyword">end</span>
0051 coder.varsize(<span class="string">'shiftedData{:}'</span>,[10000 3],[1 0]);
0052 
0053 layerSlds = cell(numberOfContrasts,1);
0054 <span class="keyword">for</span> i = 1:numberOfContrasts
0055     layerSlds{i} = [1 1 1; 1 1 1];
0056 <span class="keyword">end</span>
0057 coder.varsize(<span class="string">'layerSlds{:}'</span>,[10000 6],[1 1]);
0058 
0059 domainLayerSlds = cell(numberOfContrasts,2);
0060 <span class="keyword">for</span> i = 1:numberOfContrasts
0061     domainLayerSlds{i,1} = [1 1 1; 1 1 1];
0062     domainLayerSlds{i,2} = [1 1 1; 1 1 1];
0063 <span class="keyword">end</span>
0064 coder.varsize(<span class="string">'domainLayerSlds'</span>,[10000 2],[1 1]);
0065 coder.varsize(<span class="string">'domainLayerSlds{:}'</span>,[10000 6],[1 1]);
0066 
0067 sldProfiles = cell(numberOfContrasts,1);
0068 <span class="keyword">for</span> i = 1:numberOfContrasts
0069     sldProfiles{i,1} = [1 1; 1 1];
0070 <span class="keyword">end</span>
0071 coder.varsize(<span class="string">'sldProfiles{:}'</span>,[10000 2],[1 0]);
0072 
0073 domainSldProfiles = cell(numberOfContrasts,2);
0074 <span class="keyword">for</span> i = 1:numberOfContrasts
0075     domainSldProfiles{i,1} = [1 1; 1 1];
0076     domainSldProfiles{i,2} = [1 1; 1 1];
0077 <span class="keyword">end</span>
0078 coder.varsize(<span class="string">'domainSldProfiles'</span>,[10000 2],[1 1]);
0079 coder.varsize(<span class="string">'domainSldProfiles{:}'</span>,[10000 Inf],[1 1]);
0080 
0081 resampledLayers = cell(numberOfContrasts,1);
0082 <span class="keyword">for</span> i = 1:numberOfContrasts
0083     resampledLayers{i} = [1 1 1; 1 1 1];
0084 <span class="keyword">end</span>
0085 coder.varsize(<span class="string">'resampledLayers{:}'</span>,[10000 3],[1 0]);
0086 
0087 domainResampledLayers = cell(numberOfContrasts,2);
0088 <span class="keyword">for</span> i = 1:numberOfContrasts
0089     domainResampledLayers{i,1} = [1 1 1; 1 1 1];
0090     domainResampledLayers{i,2} = [1 1 1; 1 1 1];
0091 <span class="keyword">end</span>
0092 coder.varsize(<span class="string">'domainResampledLayers'</span>,[10000 2],[1 1]);
0093 coder.varsize(<span class="string">'domainResampledLayers{:}'</span>,[10000 3],[1 0]);
0094 
0095 <span class="comment">% Decide which target function we are calling and call the relevant routines</span>
0096 whichTF = problemStruct.TF;
0097 <span class="keyword">switch</span> whichTF
0098     <span class="keyword">case</span> coderEnums.calculationTypes.NonPolarised
0099         [contrastParams,calculationResults,reflectivity,simulation,shiftedData,layerSlds,sldProfiles,resampledLayers] = nonPolarisedTF.reflectivityCalculation(problemStruct,problemCells,controls);
0100     <span class="comment">%case coderEnums.calculationTypes.OilWater</span>
0101         <span class="comment">%contrastParams = oilWaterTFReflectivityCalculation(problemStruct,problemCells,controls);</span>
0102     <span class="comment">%case coderEnums.calculationTypes.Magnetic</span>
0103         <span class="comment">%contrastParams = polarisedTFReflectivityCalculation(problemStruct,problemCells,controls);</span>
0104     <span class="keyword">case</span> coderEnums.calculationTypes.Domains
0105         [contrastParams,calculationResults,reflectivity,simulation,shiftedData,domainLayerSlds,domainSldProfiles,domainResampledLayers] = domainsTF.reflectivityCalculation(problemStruct,problemCells,controls);
0106 <span class="comment">%     otherwise</span>
0107 <span class="comment">%         error('The calculation type &quot;%s&quot; is not supported', whichTF);</span>
0108 
0109 <span class="keyword">end</span>
0110 
0111 <span class="comment">% Make the result struct</span>
0112 result.reflectivity = reflectivity;
0113 result.simulation = simulation;
0114 result.shiftedData = shiftedData;
0115 
0116 <span class="comment">% The size of this array now varies depending on TF</span>
0117 <span class="keyword">switch</span> whichTF
0118     <span class="keyword">case</span> coderEnums.calculationTypes.Domains
0119 
0120         result.layerSlds = domainLayerSlds;
0121         result.sldProfiles = domainSldProfiles;
0122         result.resampledLayers = domainResampledLayers;
0123 
0124     <span class="keyword">otherwise</span>
0125 
0126         result.layerSlds = layerSlds;
0127         result.sldProfiles = sldProfiles;
0128         result.resampledLayers = resampledLayers;
0129 
0130 <span class="keyword">end</span>
0131 
0132 <span class="comment">% Complete the result struct</span>
0133 [~,fitNames] = packParams(problemStruct,problemCells,problemLimits,controls.checks);
0134 
0135 result.calculationResults = calculationResults;
0136 result.contrastParams = contrastParams;
0137 result.fitParams = problemStruct.fitParams;
0138 result.fitNames = fitNames;
0139 
0140 <span class="keyword">end</span>
</pre></div>

<hr><address>Generated on Tue 09-Apr-2024 08:31:11 by <strong><a href="https://github.com/gllmflndn/m2html">m2html</a></strong> &copy; 2003-2022</address>
</body>
</html>

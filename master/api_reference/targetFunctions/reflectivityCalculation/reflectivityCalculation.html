<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of reflectivityCalculation</title>
  <meta name="keywords" content="reflectivityCalculation">
  <meta name="description" content="Main entry point into the reflectivity calculation for the toolbox.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003-2019 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- # targetFunctions -->
<!-- menu.html reflectivityCalculation -->

<h1>reflectivityCalculation
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Main entry point into the reflectivity calculation for the toolbox.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [problem,result] = reflectivityCalculation(problemDef,problemDefCells,problemDefLimits,controls) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Main entry point into the reflectivity calculation for the toolbox.
 This is the main function that is called by any of the minimisers or
 analysis tools from the rest of the toolbox. 

 *The main job of this function is to decide which type of calculation
 (i.e. 'Target function' is required, and call the relevant routines.
 The types of available target functions are:*

 * non polarised  - The main basic target function type, for non polarised neutrons (or x-rays) with non-absorbing samples. Different model types are specified in sub functions from here.

 * absorption     - Identical to standardTF, but includes imaginary refractive index terms.

 * oil water      - Target function for oil-water samples

 * domains        - Target function for samples consisting of domains which are larger than the beam lateral coherence length.

 * magnetic       - Target function for cases for polarised neutrons with polarisation analysis.
                       
</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../targetFunctions/standardTF/standardTFReflectivityCalculation.html" class="code" title="function [problem,reflectivity,Simulation,shifted_data,layerSlds,sldProfiles,allLayers] = standardTFReflectivityCalculation(problemDef,problemDefCells,problemDefLimits,controls,customClass)">standardTFReflectivityCalculation</a>	Main function for the standardTF reflectivity calculation</li>
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="reflectivityCalculationWrapper.html" class="code" title="function [problem,result] = reflectivityCalculationWrapper(problemDef,problemDefCells,problemDefLimits,controls)">reflectivityCalculationWrapper</a>	This is just a wrapper function for choosing between</li>
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [problem,result] = reflectivityCalculation(problemDef,problemDefCells,problemDefLimits,controls)</a>
0002 <span class="comment">% Main entry point into the reflectivity calculation for the toolbox.</span>
0003 <span class="comment">% This is the main function that is called by any of the minimisers or</span>
0004 <span class="comment">% analysis tools from the rest of the toolbox.</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% *The main job of this function is to decide which type of calculation</span>
0007 <span class="comment">% (i.e. 'Target function' is required, and call the relevant routines.</span>
0008 <span class="comment">% The types of available target functions are:*</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% * non polarised  - The main basic target function type, for non polarised neutrons (or x-rays) with non-absorbing samples. Different model types are specified in sub functions from here.</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% * absorption     - Identical to standardTF, but includes imaginary refractive index terms.</span>
0013 <span class="comment">%</span>
0014 <span class="comment">% * oil water      - Target function for oil-water samples</span>
0015 <span class="comment">%</span>
0016 <span class="comment">% * domains        - Target function for samples consisting of domains which are larger than the beam lateral coherence length.</span>
0017 <span class="comment">%</span>
0018 <span class="comment">% * magnetic       - Target function for cases for polarised neutrons with polarisation analysis.</span>
0019 <span class="comment">%</span>
0020 
0021     
0022 <span class="comment">% for compilation, we have to preallocate memory for the output arrays</span>
0023 <span class="comment">% Setting these parameters in the struct defines them as doubles</span>
0024 problem.ssubs = 0;
0025 problem.backgrounds = 0;
0026 problem.qshifts = 0;
0027 problem.scalefactors = 0;
0028 problem.nbairs = 0;
0029 problem.nbsubs = 0;
0030 problem.resolutions = 0;
0031 problem.calculations.all_chis = 0;
0032 problem.calculations.sum_chi = 0;
0033 problem.allSubRough = 0;
0034 problem.resample = 0;
0035 
0036 <span class="comment">% We also foll the results arrays to define their</span>
0037 <span class="comment">% type and size. (NOTE: at the moment we have a 'coder.varsize'</span>
0038 <span class="comment">% pre-processor directives for the compiler here and at the</span>
0039 <span class="comment">% end for the results block. We are unlikely to need both</span>
0040 <span class="comment">% TODO: Find out which is necessary and tidy this up.</span>
0041 
0042 numberOfContrasts = problemDef.numberOfContrasts;
0043 reflectivity = cell(numberOfContrasts,1);
0044 <span class="keyword">for</span> i = 1:numberOfContrasts
0045     reflectivity{i} = [1 1 ; 1 1];
0046 <span class="keyword">end</span>
0047 coder.varsize(<span class="string">'reflectivity{:}'</span>,[10000 2],[1 0]);
0048 
0049 Simulation = cell(numberOfContrasts,1);
0050 <span class="keyword">for</span> i = 1:numberOfContrasts
0051     Simulation{i} = [1 1 ; 1 1];
0052 <span class="keyword">end</span>
0053 coder.varsize(<span class="string">'Simulation{:}'</span>,[10000 2],[1 0]);
0054 
0055 shifted_data = cell(numberOfContrasts,1);
0056 <span class="keyword">for</span> i = 1:numberOfContrasts
0057     shifted_data{i} = [1 1 1 ; 1 1 1];
0058 <span class="keyword">end</span>
0059 coder.varsize(<span class="string">'shifted_data{:}'</span>,[10000 3],[1 0]);
0060 
0061 layerSlds = cell(numberOfContrasts,1);
0062 <span class="keyword">for</span> i = 1:numberOfContrasts
0063     layerSlds{i} = [1 1 1 ; 1 1 1];
0064 <span class="keyword">end</span>
0065 coder.varsize(<span class="string">'layerSlds{:}'</span>,[10000 3],[1 0]);
0066 
0067 sldProfiles = cell(numberOfContrasts,1);
0068 <span class="keyword">for</span> i = 1:numberOfContrasts
0069     sldProfiles{i} = [1 1 ; 1 1];
0070 <span class="keyword">end</span>
0071 coder.varsize(<span class="string">'sldProfiles{:}'</span>,[10000 2],[1 0]);
0072 
0073 allLayers = cell(numberOfContrasts,1);
0074 <span class="keyword">for</span> i = 1:numberOfContrasts
0075     allLayers{i} = [1 1 1; 1 1 1];
0076 <span class="keyword">end</span>
0077 coder.varsize(<span class="string">'allLayers{:}'</span>,[10000 3],[1 0]);
0078 
0079 
0080 <span class="comment">% Decide which target function we are calling and call the relevant routines</span>
0081 whichTF = problemDef.TF;
0082 <span class="keyword">switch</span> whichTF
0083     <span class="keyword">case</span> <span class="string">'non polarised'</span>
0084         [problem,reflectivity,Simulation,shifted_data,layerSlds,sldProfiles,allLayers] = <a href="../../targetFunctions/standardTF/standardTFReflectivityCalculation.html" class="code" title="function [problem,reflectivity,Simulation,shifted_data,layerSlds,sldProfiles,allLayers] = standardTFReflectivityCalculation(problemDef,problemDefCells,problemDefLimits,controls,customClass)">standardTFReflectivityCalculation</a>(problemDef,problemDefCells,problemDefLimits,controls);
0085     <span class="comment">%case 'absorption'</span>
0086         <span class="comment">%[problem,reflectivity,Simulation,shifted_data,layerSlds,sldProfiles,allLayers] = standardTFAbs_reflectivityCalculation(problemDef,problemDefCells,problemDefLimits,controls);</span>
0087     <span class="comment">%case 'oil water'</span>
0088         <span class="comment">%problem = oilWaterTF_reflectivityCalculation(problemDef,problemDefCells,controls);</span>
0089     <span class="comment">%case 'magnetic'</span>
0090         <span class="comment">%problem = polarisedTF_reflectivityCalculation(problemDef,problemDefCells,controls);</span>
0091     <span class="comment">%case 'domains'</span>
0092         <span class="comment">%[problem,reflectivity,Simulation,shifted_data,layerSlds,sldProfiles,allLayers] = domainsTF_reflectivityCalculation(problemDef,problemDefCells,problemDefLimits,controls);</span>
0093     <span class="comment">%otherwise</span>
0094         <span class="comment">%error('The calculation type &quot;%s&quot; is not supported', whichTF);</span>
0095 
0096 <span class="keyword">end</span>
0097 
0098 result = cell(1,6);
0099 
0100 cell1 = cell(numberOfContrasts,1);
0101 <span class="keyword">for</span> i = 1:numberOfContrasts
0102     cell1{i} = reflectivity{i};
0103 <span class="keyword">end</span>
0104 result{1} = cell1;
0105 
0106 cell2 = cell(numberOfContrasts,1);
0107 <span class="keyword">for</span> i = 1:numberOfContrasts
0108     cell2{i} = Simulation{i};
0109 <span class="keyword">end</span>
0110 result{2} = cell2;
0111 
0112 cell3 = cell(numberOfContrasts,1);
0113 <span class="keyword">for</span> i = 1:numberOfContrasts
0114     cell3{i} = shifted_data{i}; 
0115 <span class="keyword">end</span>
0116 result{3} = cell3;
0117  
0118 cell4 = cell(numberOfContrasts,1);
0119 <span class="keyword">for</span> i = 1:numberOfContrasts
0120     cell4{i} = layerSlds{i};
0121 <span class="keyword">end</span>
0122 result{4} = cell4;
0123  
0124 cell5 = cell(numberOfContrasts,1);
0125 <span class="keyword">for</span> i = 1:numberOfContrasts
0126     cell5{i} = sldProfiles{i}; 
0127 <span class="keyword">end</span>
0128 result{5} = cell5;
0129  
0130 cell6 = cell(numberOfContrasts,1);
0131 <span class="keyword">for</span> i = 1:numberOfContrasts
0132     cell6{i} = allLayers{i}; 
0133 <span class="keyword">end</span>
0134 result{6} = cell6;
0135 
0136 <span class="comment">% Pre-processor directives for Matlab Coder</span>
0137 <span class="comment">% to define the size of the output array</span>
0138 coder.varsize(<span class="string">'problem.ssubs'</span>,[Inf 1],[1 0]);
0139 coder.varsize(<span class="string">'problem.backgrounds'</span>,[Inf 1],[1 0]);
0140 coder.varsize(<span class="string">'problem.qshifts'</span>,[Inf 1],[1 0]);
0141 coder.varsize(<span class="string">'problem.scalefactors'</span>,[Inf 1],[1 0]);
0142 coder.varsize(<span class="string">'problem.nbairs'</span>,[Inf 1],[1 0]);
0143 coder.varsize(<span class="string">'problem.nbsubs'</span>,[Inf 1],[1 0]);
0144 coder.varsize(<span class="string">'problem.resolutions'</span>,[Inf 1],[1 0]);
0145 coder.varsize(<span class="string">'problem.ssubs'</span>,[Inf 1],[1 0]);
0146 coder.varsize(<span class="string">'problem.calculations.all_chis'</span>,[Inf 1],[1 0]);
0147 coder.varsize(<span class="string">'problem.calculations.sum_chi'</span>,[1 1],[0 0]);
0148 coder.varsize(<span class="string">'problem.allSubRough'</span>,[Inf 1],[1 0]);
0149 coder.varsize(<span class="string">'problem.resample'</span>,[1 Inf],[0 1]);
0150 
0151 <span class="comment">%Result coder definitions....</span>
0152 coder.varsize(<span class="string">'result{1}'</span>,[Inf 1],[1 0]);           <span class="comment">%Reflectivity</span>
0153 coder.varsize(<span class="string">'result{1}{:}'</span>,[Inf 2],[1 0]);
0154 
0155 coder.varsize(<span class="string">'result{2}'</span>,[Inf 1],[1 0]);           <span class="comment">%Simulatin</span>
0156 coder.varsize(<span class="string">'result{2}{:}'</span>,[Inf 2],[1 0]);
0157 
0158 coder.varsize(<span class="string">'result{3}'</span>,[Inf 1],[1 0]);           <span class="comment">%Shifted data</span>
0159 coder.varsize(<span class="string">'result{3}{:}'</span>,[Inf 3],[1 0]);
0160 
0161 coder.varsize(<span class="string">'result{4}'</span>,[Inf 1],[1 0]);           <span class="comment">%Layers slds</span>
0162 coder.varsize(<span class="string">'result{4}{:}'</span>,[Inf 3],[1 0]);
0163 
0164 coder.varsize(<span class="string">'result{5}'</span>,[Inf 1],[1 0]);           <span class="comment">%Sld profiles</span>
0165 coder.varsize(<span class="string">'results{5}{:}'</span>,[Inf 2],[1 0]);
0166 
0167 coder.varsize(<span class="string">'result{6}'</span>,[Inf 1],[1 0]);           <span class="comment">%All layers (resampled)</span>
0168 coder.varsize(<span class="string">'result{6}{:}'</span>,[Inf 3],[1 0]);
0169 
0170 <span class="keyword">end</span>
</pre></div>

<hr><address>Generated on Wed 10-May-2023 12:43:42 by <strong><a href="https://github.com/gllmflndn/m2html">m2html</a></strong> &copy; 2003-2022</address>
</body>
</html>

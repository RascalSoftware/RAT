<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of standardTFStandardLayersParallelPoints</title>
  <meta name="keywords" content="standardTFStandardLayersParallelPoints">
  <meta name="description" content="Standard Layers calculation paralelised over the inner loop">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003-2019 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- # targetFunctions -->
<!-- ../menu.html standardTF -->
<!-- menu.html standardLayers -->

<h1>standardTFStandardLayersParallelPoints
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>Standard Layers calculation paralelised over the inner loop</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [outSsubs,backgs,qshifts,sfs,nbas,nbss,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,sldProfiles,allLayers,allRoughs] = standardTFStandardLayersParallelPoints(problemDef,problemDefCells,problemDefLimits,controls) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Standard Layers calculation paralelised over the inner loop
 This is the main reflectivity calculation of the standard layers
 calculation type. It extracts the required parameters for the contrasts
 from the input arrays, then passes the main calculation to
 'standardLayersCore', which carries out the calculation iteself. 
 The core calculation is common for both standard and custom layers.
</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../API/extractProblemParams.html" class="code" title="function [numberOfContrasts, geometry, cBacks, cShifts, cScales, cNbas, cNbss,cRes, backs, shifts, sf, nba, nbs, res, dataPresent, nParams, params,numberOfLayers, resample, backsType, cFiles] =  extractProblemParams(problemDef)">extractProblemParams</a>	Extract individual parameters from problemDef</li>
<li><a href="../../../API/parseCells.html" class="code" title="function [repeatLayers,allData,dataLimits,simLimits,contrastLayers,layersDetails,customFiles] = parseCells(problemDefCells)">parseCells</a>	Splits up the master input list of all arrays into separate arrays</li>
<li><a href="../../../targetFunctions/common/backSort/backSort.html" class="code" title="function [backg,qshift,sf,nba,nbs,resol] = backSort(cBacks,cShifts,cScales,cNbas,cNbss,cRes,backs,shifts,sf,nba,nbs,res)">backSort</a>	Distributes the background and shift values among the different contrasts</li>
<li><a href="../../../targetFunctions/common/groupLayers/allocateLayersForContrast.html" class="code" title="function     thisContrastLayers = allocateLayersForContrast(contrastLayers,outParameterisedLayers,useImaginary)">allocateLayersForContrast</a>	Decide which layers are needed for a particular contrast.</li>
<li><a href="../../../targetFunctions/common/groupLayers/allocateParamsToLayers.html" class="code" title="function outLayers = allocateParamsToLayers(params, layersDetails)">allocateParamsToLayers</a>	Allocates parameters from the parameter array to the correct layers</li>
<li><a href="../../../targetFunctions/standardTF/standardTFLayersCore.html" class="code" title="function [sldProfile,reflect,Simul,shifted_dat,theseLayers,resamLayers,chiSq,ssubs] =standardTFLayersCore(contrastLayers, rough,geometry, nba, nbs, resample, calcSld, sf, qshift,dataPresent, data, dataLimits, simLimits, repeatLayers,background,resol,backsType,params,parallelPoints,resamPars,useImaginary)">standardTFLayersCore</a>	This is the main reflectivity calculation for all Layers models in the</li>
</ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../targetFunctions/standardTF/standardTFStandardLayersReflectivityCalculation.html" class="code" title="function [problem,reflectivity,Simulation,shifted_data,layerSlds,sldProfiles,allLayers] = standardTFStandardLayersReflectivityCalculation(problemDef,problemDefCells,problemDefLimits,controls)">standardTFStandardLayersReflectivityCalculation</a>	Standard layers reflectivity calculation for standardTF</li>
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 
0002 <a name="_sub0" href="#_subfunctions" class="code">function [outSsubs,backgs,qshifts,sfs,nbas,nbss,resols,chis,reflectivity,</a><span class="keyword">...</span>
0003     Simulation,shifted_data,layerSlds,sldProfiles,allLayers,<span class="keyword">...</span>
0004     allRoughs] = standardTFStandardLayersParallelPoints(problemDef,problemDefCells,<span class="keyword">...</span>
0005     problemDefLimits,controls)
0006 <span class="comment">% Standard Layers calculation paralelised over the inner loop</span>
0007 <span class="comment">% This is the main reflectivity calculation of the standard layers</span>
0008 <span class="comment">% calculation type. It extracts the required parameters for the contrasts</span>
0009 <span class="comment">% from the input arrays, then passes the main calculation to</span>
0010 <span class="comment">% 'standardLayersCore', which carries out the calculation iteself.</span>
0011 <span class="comment">% The core calculation is common for both standard and custom layers.</span>
0012 
0013 
0014 <span class="comment">% Extract individual cell arrays</span>
0015 [repeatLayers,<span class="keyword">...</span>
0016  allData,<span class="keyword">...</span>
0017  dataLimits,<span class="keyword">...</span>
0018  simLimits,<span class="keyword">...</span>
0019  contrastLayers,<span class="keyword">...</span>
0020  layersDetails<span class="keyword">...</span>
0021  customFiles] = <a href="../../../API/parseCells.html" class="code" title="function [repeatLayers,allData,dataLimits,simLimits,contrastLayers,layersDetails,customFiles] = parseCells(problemDefCells)">parseCells</a>(problemDefCells);
0022 
0023 <span class="comment">% Extract individual parameters from problemDef struct</span>
0024 [numberOfContrasts, geometry, cBacks, cShifts, cScales, cNbas, cNbss,<span class="keyword">...</span>
0025 cRes, backs, shifts, sf, nba, nbs, res, dataPresent, nParams, params,<span class="keyword">...</span>
0026 numberOfLayers, resample, backsType, cCustFiles] =  <a href="../../../API/extractProblemParams.html" class="code" title="function [numberOfContrasts, geometry, cBacks, cShifts, cScales, cNbas, cNbss,cRes, backs, shifts, sf, nba, nbs, res, dataPresent, nParams, params,numberOfLayers, resample, backsType, cFiles] =  extractProblemParams(problemDef)">extractProblemParams</a>(problemDef);
0027 
0028 calcSld = controls.calcSld;   
0029 useImaginary = problemDef.useImaginary;
0030 
0031 <span class="comment">% Allocate the memory for the output arrays before the main loop</span>
0032 backgs = zeros(numberOfContrasts,1);
0033 qshifts = zeros(numberOfContrasts,1);
0034 sfs = zeros(numberOfContrasts,1);
0035 nbas = zeros(numberOfContrasts,1);
0036 nbss = zeros(numberOfContrasts,1);
0037 resols = zeros(numberOfContrasts,1);
0038 allRoughs = zeros(numberOfContrasts,1);
0039 outSsubs = zeros(numberOfContrasts,1);
0040 chis =  zeros(numberOfContrasts,1);
0041 layerSlds = cell(numberOfContrasts,1);
0042 sldProfiles = cell(numberOfContrasts,1);
0043 shifted_data = cell(numberOfContrasts,1);
0044 
0045 reflectivity = cell(numberOfContrasts,1);
0046 <span class="keyword">for</span> i = 1:numberOfContrasts
0047     reflectivity{i} = [1 1 ; 1 1];
0048 <span class="keyword">end</span>
0049 
0050 Simulation = cell(numberOfContrasts,1);
0051 <span class="keyword">for</span> i = 1:numberOfContrasts
0052     Simulation{i} = [1 1 ; 1 1];
0053 <span class="keyword">end</span>
0054 
0055 allLayers = cell(numberOfContrasts,1);
0056 <span class="keyword">for</span> i = 1:numberOfContrasts
0057     allLayers{i} = [1 1 1; 1 1 1];
0058 <span class="keyword">end</span>
0059 <span class="comment">% end memory allocation.</span>
0060 
0061 
0062 <span class="comment">% First we need to allocate the absolute values of the input</span>
0063 <span class="comment">% parameters to all the layers in the layers list. This only needs</span>
0064 <span class="comment">% to be done once, and so is done outside the contrasts loop</span>
0065 outParameterisedLayers = <a href="../../../targetFunctions/common/groupLayers/allocateParamsToLayers.html" class="code" title="function outLayers = allocateParamsToLayers(params, layersDetails)">allocateParamsToLayers</a>(params, layersDetails);
0066 
0067 <span class="comment">% Resample params if requiired</span>
0068 resamPars = controls.resamPars;
0069 
0070 <span class="comment">% Loop over all the contrasts</span>
0071 <span class="keyword">for</span> i = 1:numberOfContrasts
0072     
0073     <span class="comment">% Extract the relevant parameter values for this contrast</span>
0074     <span class="comment">% from the input arrays.</span>
0075     <span class="comment">% First need to decide which values of the backgrounds, scalefactors</span>
0076     <span class="comment">% data shifts and bulk contrasts are associated with this contrast</span>
0077     [thisBackground,thisQshift,thisSf,thisNba,thisNbs,thisResol] = <a href="../../../targetFunctions/common/backSort/backSort.html" class="code" title="function [backg,qshift,sf,nba,nbs,resol] = backSort(cBacks,cShifts,cScales,cNbas,cNbss,cRes,backs,shifts,sf,nba,nbs,res)">backSort</a>(cBacks(i),cShifts(i),cScales(i),cNbas(i),cNbss(i),cRes(i),backs,shifts,sf,nba,nbs,res);
0078     
0079     <span class="comment">% Also need to determine which layers from the overall layers list</span>
0080     <span class="comment">% are required for this contrast, and put them in the correct order</span>
0081     <span class="comment">% according to geometry</span>
0082     thisContrastLayers = <a href="../../../targetFunctions/common/groupLayers/allocateLayersForContrast.html" class="code" title="function     thisContrastLayers = allocateLayersForContrast(contrastLayers,outParameterisedLayers,useImaginary)">allocateLayersForContrast</a>(contrastLayers{i},outParameterisedLayers,useImaginary);
0083     
0084     <span class="comment">% For the other parameters, we extract the correct ones from the input</span>
0085     <span class="comment">% arrays</span>
0086     thisRough = params(1);      <span class="comment">% Substrate roughness is always first parameter for standard layers</span>
0087     thisRepeatLayers = repeatLayers{i};
0088     thisResample = resample(i);
0089     thisCalcSld = calcSld;
0090     thisData = allData{i};
0091     thisDataPresent = dataPresent(i);
0092     thisDataLimits = dataLimits{i};
0093     thisSimLimits = simLimits{i};
0094     thisBacksType = backsType(i);
0095     
0096     <span class="comment">% Now call the core standardTF_stanlay reflectivity calculation</span>
0097     <span class="comment">% In this case we are single cored, so we do not parallelise over</span>
0098     <span class="comment">% points</span>
0099     parallelPoints = <span class="string">'points'</span>;
0100     
0101     <span class="comment">% Call the core layers calculation</span>
0102     [sldProfile,reflect,Simul,shifted_dat,layerSld,resampledLayers,<span class="keyword">...</span>
0103         thisChiSquared,thisSsubs] = <a href="../../../targetFunctions/standardTF/standardTFLayersCore.html" class="code" title="function [sldProfile,reflect,Simul,shifted_dat,theseLayers,resamLayers,chiSq,ssubs] =standardTFLayersCore(contrastLayers, rough,geometry, nba, nbs, resample, calcSld, sf, qshift,dataPresent, data, dataLimits, simLimits, repeatLayers,background,resol,backsType,params,parallelPoints,resamPars,useImaginary)">standardTFLayersCore</a>(thisContrastLayers, thisRough, <span class="keyword">...</span>
0104     geometry, thisNba, thisNbs, thisResample, thisCalcSld, thisSf, thisQshift,<span class="keyword">...</span>
0105     thisDataPresent, thisData, thisDataLimits, thisSimLimits, thisRepeatLayers,<span class="keyword">...</span>
0106     thisBackground,thisResol,thisBacksType,nParams,parallelPoints,resamPars,useImaginary);
0107    
0108     <span class="comment">% Store returned values for this contrast in the output arrays.</span>
0109     <span class="comment">% As well as the calculated profiles, we also store a record of</span>
0110     <span class="comment">% the other values (background, scalefactors etc) for each contrast</span>
0111     <span class="comment">% for future use.</span>
0112     outSsubs(i) = thisSsubs;
0113     sldProfiles{i} = sldProfile;
0114     reflectivity{i} = reflect;
0115     Simulation{i} = Simul;
0116     shifted_data{i} = shifted_dat;
0117     layerSlds{i} = layerSld;
0118     chis(i) = thisChiSquared;
0119     backgs(i) = thisBackground;
0120     qshifts(i) = thisQshift;
0121     sfs(i) = thisSf;
0122     nbas(i) = thisNba;
0123     nbss(i) = thisNbs;
0124     resols(i) = thisResol;
0125     allRoughs(i) = thisRough;
0126     allLayers{i} = resampledLayers;
0127 <span class="keyword">end</span>
0128 
0129 <span class="keyword">end</span>
</pre></div>

<hr><address>Generated on Fri 20-Oct-2023 14:33:25 by <strong><a href="https://github.com/gllmflndn/m2html">m2html</a></strong> &copy; 2003-2022</address>
</body>
</html>
